(* extracted from use of pairwise independent hash function in Waters scheme *)

adversary A1 : () -> Fq.
adversary A2 : Fq -> Bool.

oracle O : Fq -> Fq.

(* For the first adversary call *)
bound_dist
  [ j <- A1() with
        O(i) =
          [ (* for < *)
            [ 0 ]
            (* for = *)
            [ t1 | t1 <-$ Fq ]
            (* for > *)
            [ 0 ] ];
    t2 <-$ Fq;
    beta <- A2(t2);
  ] : beta /\ (O`i<>j)
  [ a <-$ Fq;
    b <-$ Fq;
    j <- A1() with
        O(i) =
          [ (* for < *)
            [ 0 ]
            (* for = *)
            [ a*i + b ]
            (* for > *)
            [ 0 ] ];
    beta <- A2(a*j + b);
  ] : beta /\ (O`i<>j).
  rename t2 a.
  assert a (O`i<>j). (* add assert to enable rnd rule *)
    bycrush.
  rnd a (a -> O`t1 + a*(j - O`i)) _; //.
  swap a -2.
  rnd_oracle (2,1,1,=) (t1 -> t1 + a*i) _; //.
  swap_main (2,1,1) b.
  assert 4. (* remove assert again *)
    bycrush.
  dist_eq.
qed.

(* for the second adversary call *)
bound_dist
  [ j <- A1();
    t1 <-$ Fq;
    beta <- A2(t1)
      with
        O(i) =
          [ (* for < *)
            [ 0 ]
            (* for = *)
            [ t
            | i <> j,
              t <-$ Fq
            ]
            (* for > *)
            [ 0 ] ];
  ] : beta
  [ a <-$ Fq;
    b <-$ Fq;
    j <- A1();
    beta <- A2(a*j + b)
      with
        O(i) =
          [ (* for < *)
            [ 0 ]
            (* for = *)
            [ a*i + b | i<>j ]
            (* for > *)
            [ 0 ] ];
  ] : beta.
  
  swap t1 -1.
  rename t1 b.
  (* since we want to make A2's input depend on a and b, we have to adapt
     the oracle first (already taking the rnd rule later used for b into
     account *)
  rnd_oracle (3,1,2,=) (t -> t*(i - j) + b) _; //.
  swap_main (3,1,2) a.
  swap b a.
  rnd b (b -> b + a*j) _; //.
  swap b j.
  swap a b.
  dist_eq.
qed.