adversary A1 : G -> (G * G).
adversary A2 : (G * G) -> Bool.
assumption ddh
  [ x <-$ Fq; y <-$ Fq;
    let gx = g ^ x; let gy = g ^ y; let gxy = g ^ (x * y); ]
  [ x <-$ Fq; y <-$ Fq; z <-$ Fq;
    let gx = g ^ x; let gy = g ^ y; let gxy = g ^ z; ]
    x y z.

prove
  [ a <-$ Fq;
    x <-$ Fq;
    (m0,m1) <- A1(g^a);
    b <-$ Bool;
    let mb = (b?m0:m1);
    b' <- A2(mb * g^(a*x), g^x);
  ] : b = b'.
 
  (* auto would start with norm *)
  rnorm.
  (* 1. Type match samplings in game with samplings in assumption:
       a) G.x <-> A.x, G.a <-> A.y
       b) G.a <-> A.x, G.x <-> A.y
    2. Express game without x and y (and z)
       Known for (a) :
         gx := g^x, gy := g^a, gxy := g^ax
       Required:
         g^a ==> OK
         g^x ==> OK
         g ^ (a*x + log((b?m0:m1)))
         Known at this point:
           in G: p1 := m0, p2 := m1, ga := g^a, gx := g^x, gax := g^ax
         our deducibility should return a recipe
         without log, for example:
           gax*(b?p1:p2)
         We can then instantiate p1 and p2 with the respective values
         and just insert the let-abstractions.
 *)
 rnorm_unknown a x.
 rlet_abstract 2 xa (g^a).
 rlet_abstract 3 xx (g^x).
 rlet_abstract 4 xax (g^(a*x)).
 assumption -> ddh c. rnorm. rswap 3 2.
 rrandom 5 _ (u -> u + log(b?m0:m1)) z1.
 rnorm.
 rswap 4 2.
 rindep.