adversary A1 : (G * G * G * G) -> (G * G).
adversary A2 : (G * G * G * G) -> Bool.
oracle Dec : (G * G * G * G) -> G.
(* not really a random oracle, change this later *)
random oracle H : (G * G * G) -> Fq.

prove
  [ w  <-$ Fq;
    x1 <-$ Fq;
    x2 <-$ Fq;
    y1 <-$ Fq;
    y2 <-$ Fq;
    z1 <-$ Fq;
    z2 <-$ Fq;
    let p1 = g^(x1+w*x2);
    let p2 = g^(y1+w*y2);
    let p3 = g^(z1+w*z2);
    let p4 = g^w;
    (m0,m1) <- A1(p1,p2,p3,p4);
    b <-$ Bool;
    let mb = (b?m0:m1);
    u <-$ Fq;
    let sa = g^u;
    let sa' = p4^u;
    let sc = mb * p3^u;
    let sd = p1^u * p2^(u*H(sa,sa',sc));
    b' <- A2(sa,sa',sc,sd) with
      Dec(a,a',c,d) =
        [ c * (a^z1 * a'^z2)^(-1)
        | not (a = sa), not(a' = sa'), not(c = sc), not(d = sd),
          d = a^(x1+H(a,a',c)*y1) * a'^(x2+H(a,a',c)*y2) ];
  ] : b = b'. print_goals : start.

  rswap 15 -13.  print_goals : swap1.

  rnorm. rnorm_unknown (u,w). print_goals : norm_uk1.
  rlet_abstract 2 gw g^w. print_goals : alet1.
  rlet_abstract 3 gu g^u. print_goals : alet2.
  rlet_abstract 4 gwu g^(w*u). 
  rddh v. print_goals : after_ddh.
  requiv
    [ w  <-$ Fq;
      u <-$ Fq;
      v <-$ Fq;
      x1 <-$ Fq;
      x2 <-$ Fq;
      y1 <-$ Fq;
      y2 <-$ Fq;
      z1 <-$ Fq;
      z2 <-$ Fq;
      (m0,m1) <- A1(g^(x1+w*x2),g^(y1+w*y2),g^(z1+w*z2),g^w);
      b <-$ Bool;
      let mb = (b?m0:m1);
      let sa  = g^u;
      let sa' = g^v;
      let sc  = mb * g^(u*z1 + v*z2);
      let sd  = g^(u*x1 + v*x2) * g^(y1*u*H(sa,sa',sc) + y2*v*H(sa,sa',sc));
      b' <- A2(sa,sa',sc,sd) with
        Dec(a,a',c,d) =
          [ c * (a^z1 * a'^z2)^(-1)
          | not (a = sa), not(a' = sa'), not(c = sc), not(d = sd),
            d = a^(x1+H(a,a',c)*y1) * a'^(x2+H(a,a',c)*y2) ];
    ] : b = b'. print_goals : equiv.

  (* We first perform a step based on statistical distance where we
     replace 'v <-$ Fq' by 'v <-$ Fq \ u*w'
  *)
  prove
    [ w  <-$ Fq;
      u <-$ Fq;
      v <-$ Fq \ u*w;
      x1 <-$ Fq;
      x2 <-$ Fq;
      y1 <-$ Fq;
      y2 <-$ Fq;
      z1 <-$ Fq;
      z2 <-$ Fq;
      (m0,m1) <- A1(g^(x1+w*x2),g^(y1+w*y2),g^(z1+w*z2),g^w);
      b <-$ Bool;
      let mb = (b?m0:m1);
      let sa  = g^u;
      let sa' = g^v;
      let sc  = mb * g^(u*z1 + v*z2);
      let sd  = g^(u*x1 + v*x2) * g^(y1*u*H(sa,sa',sc) + y2*v*H(sa,sa',sc));
      b' <- A2(sa,sa',sc,sd) with
        Dec(a,a',c,d) =
          [ c * (a^z1 * a'^z2)^(-1)
          | not (a = sa), not(a' = sa'), not(c = sc), not(d = sd),
            d = a^(x1+H(a,a',c)*y1) * a'^(x2+H(a,a',c)*y2) ];
    ] : b' = b. print_goals : equiv.

  (* We add the test @a^w = a'@ to the decryption oracle.
     In goal_1, we continue with the strengthened test.
     In goal_2, the test is strengthened and the adversary must
     return bad (a,a',c,d) where the old test succeeds, but
     a^w <>  a'.
     *)
  prove
    [ w  <-$ Fq;
      u <-$ Fq;
      v <-$ Fq \ u*w;
      x1 <-$ Fq;
      x2 <-$ Fq;
      y1 <-$ Fq;
      y2 <-$ Fq;
      z1 <-$ Fq;
      z2 <-$ Fq;
      (m0,m1) <- A1(g^(x1+w*x2),g^(y1+w*y2),g^(z1+w*z2),g^w);
      b <-$ Bool;
      let mb = (b?m0:m1);
      let sa  = g^u;
      let sa' = g^v;
      let sc  = mb * g^(u*z1 + v*z2);
      let sd  = g^(u*x1 + v*x2) * g^(y1*u*H(sa,sa',sc) + y2*v*H(sa,sa',sc));
      b' <- A2(sa,sa',sc,sd) with
        Dec(a,a',c,d) =
          [ c * (a^z1 * a'^z2)^(-1)
          | not (a = sa), not(a' = sa'), not(c = sc), not(d = sd),
            a^w = a',
            d = a^(x1+H(a,a',c)*y1) * a'^(x2+H(a,a',c)*y2) ];
    ] : b = b'. print_goals : goal_1.

  (* equivalent test, we exploit the identity a^w = a'. *)
  prove
    [ w  <-$ Fq;
      u <-$ Fq;
      v <-$ Fq \ u*w;
      x1 <-$ Fq;
      x2 <-$ Fq;
      y1 <-$ Fq;
      y2 <-$ Fq;
      z1 <-$ Fq;
      z2 <-$ Fq;
      (m0,m1) <- A1(g^(x1+w*x2),g^(y1+w*y2),g^(z1+w*z2),g^w);
      b <-$ Bool;
      let mb = (b?m0:m1);
      let sa  = g^u;
      let sa' = g^v;
      let sc  = mb * g^(u*z1 + v*z2);
      let sd  = g^(u*x1 + v*x2) * g^(y1*u*H(sa,sa',sc) + y2*v*H(sa,sa',sc));
      b' <- A2(sa,sa',sc,sd) with
        Dec(a,a',c,d) =
          [ c * (a^(z1 + w*z2))^(-1)
          | not (a = sa), not(a' = sa'), not(c = sc), not(d = sd),
            a^w = a',
            d = (a^(x1+H(a,a',c)*y1 + w*(x2+H(a,a',c)*y2))) ];
    ] : b = b'. print_goals : goal_1_1.

  (* We want to make 'u*z1 + v*z2' random independent of the remaining
     exponents since this would allow us to get rid of mb in the next step.
     Note that we cannot, apply random to u and v since both occur on their
     own. So we try to apply random to z1 and z2.
     We get the following exponents involving the two:
     
     z1   + w*z2
     u*z1 + v*z2

     We want to make
        z1   + w*z2 = z1_new
        u*z1 + v*z2 = z2_new
     =>  z1 = z1_new - w*z2 and after replacing in the second equation, we get
         u*z1_new - u*w*z2 + v*z2 = z2_new
     ==> z2 = (z2_new - u * z1_new) / (v - u*w)

     ==> we must sample v from Fq \ {u*w}
     *)
     rswap 8 1.
     rrandom 9 (y -> y - w*z2) (y -> y + w*z2) zz. rlet_unfold 10.
     rnorm_nounfold. rswap 8 4.  print_goals : rand_z1.
     rrandom 12 (y -> (y - log(mb) - u*z1)/(v-u*w))
                (y -> u*z1 + (v-u*w)*y + log(mb)) zzz.
     rlet_unfold 13. rlet_unfold 11. rnorm_nounfold. rswap 10 6. print_goals : rand_z1.
     rindep. print_goals : goal1_finished.

(* goal_2: we have guessed the bad query and performed a reduction
   such that a new adversary call A3 returns the bad values directly *)
adversary A3 : () -> (G * G * G *G).

  prove
    [ w  <-$ Fq;
      u <-$ Fq;
      v <-$ Fq \ u*w;
      x1 <-$ Fq;
      x2 <-$ Fq;
      y1 <-$ Fq;
      y2 <-$ Fq;
      z1 <-$ Fq;
      z2 <-$ Fq;
      (m0,m1) <- A1(g^(x1+w*x2),g^(y1+w*y2),g^(z1+w*z2),g^w);
      b <-$ Bool;
      let mb = (b?m0:m1);
      let sa  = g^u;
      let sa' = g^v;
      let sc  = mb * g^(u*z1 + v*z2);
      let sd  = g^(u*x1 + v*x2) * g^(y1*u*H(sa,sa',sc) + y2*v*H(sa,sa',sc));
      b' <- A2(sa,sa',sc,sd) with
        Dec(a,a',c,d) =
          [ c * (a^z1 * a'^z2)^(-1)
          | not (a = sa), not(a' = sa'), not(c = sc), not(d = sd),
            a^w = a',
            d = a^(x1+H(a,a',c)*y1) * a'^(x2+H(a,a',c)*y2) ];
      (ba,ba',bc,bd) <- A3();
    ] : not(ba^w = ba')
        /\ not (ba = sa) /\ not(ba' = sa') /\ not(bc = sc) /\ not(bd = sd)
        /\ (bd = (ba^(x1+H(ba,ba',bc)*y1) * ba'^(x2+H(ba,ba',bc)*y2))).
    print_goals : goal_2.
  (* we rewrite the test to exploit the equality *)
  prove
    [ w  <-$ Fq;
      u <-$ Fq;
      v <-$ Fq;
      x1 <-$ Fq;
      x2 <-$ Fq;
      y1 <-$ Fq;
      y2 <-$ Fq;
      z1 <-$ Fq;
      z2 <-$ Fq;
      (m0,m1) <- A1(g^(x1+w*x2),g^(y1+w*y2),g^(z1+w*z2),g^w);
      b <-$ Bool;
      let mb = (b?m0:m1);
      let sa  = g^u;
      let sa' = g^v;
      let sc  = mb * g^(u*z1 + v*z2);
      let sd  = g^(u*x1 + v*x2) * g^(y1*u*H(sa,sa',sc) + y2*v*H(sa,sa',sc));
      b' <- A2(sa,sa',sc,sd) with
        Dec(a,a',c,d) =
          [ c * (a^(z1 + w*z2))^(-1)
          | not (a = sa), not(a' = sa'), not(c = sc), not(d = sd),
            a^w = a',
            d = a^(x1+H(a,a',c)*y1 + w*(x2+H(a,a',c)*y2)) ];
      (ba,ba',bc,bd) <- A3();
    ] : not(ba^w = ba')
        /\ not (ba = sa) /\ not(ba' = sa') /\ not(bc = sc) /\ not(bd = sd)
        /\ (bd = (ba^(x1+H(ba,ba',bc)*y1) * ba'^(x2+H(ba,ba',bc)*y2))).
    print_goals : goal_2.

    (* we check all the randomly sampled variables.
       These occur _directly_ in exponents:
       w, u, v
       These occur only in more complicated terms:
       x1     x2      y1         y2       z1      z2
       ------------------------------------------------
   1 | x1   + x2*w
   2 |                y1      +  y2*w
   3 |                                    z1   +  z2*w
   4 | u*x1 + x2*v
   5 |                y1*u*hs  + y2*v*hs
   6 | x1   + x2*w +  y1*hi    + y2*hi
   7 | x1          +  y1*hb
   8 |        x2               + y2*hb   

       where hs = H(sa,sa',sc)
             hi = H(a,a',c) from i-th query
             hb = H(ba,ba',bc)
*)

