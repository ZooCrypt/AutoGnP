adversary A1 : (G * G * G * G) -> (G * G).
adversary A2 : (G * G * G * G) -> Bool.
oracle Dec : (G * G * G * G) -> G.
(* not really a random oracle, change this later *)
random oracle H : (G * G * G) -> Fq.

prove
  [ w  <-$ Fq;
    x1 <-$ Fq;
    x2 <-$ Fq;
    y1 <-$ Fq;
    y2 <-$ Fq;
    z1 <-$ Fq;
    z2 <-$ Fq;
    let p1 = g^(x1+w*x2);
    let p2 = g^(y1+w*y2);
    let p3 = g^(z1+w*z2);
    let p4 = g^w;
    (m0,m1) <- A1(p1,p2,p3,p4);
    b <-$ Bool;
    let mb = (b?m0:m1);
    u <-$ Fq;
    let sa = g^u;
    let sa' = p4^u;
    let sc = mb * p3^u;
    let sd = p1^u * p2^(u*H(sa,sa',sc));
    b' <- A2(sa,sa',sc,sd) with
      Dec(a,a',c,d) =
        [ c * (a^z1 * a'^z2)^(-1)
        | not (a = sa), not(a' = sa'), not(c = sc), not(d = sd),
          d = a^(x1+H(a,a',c)*y1) * a'^(x2+H(a,a',c)*y2) ];
  ] : b = b'. print_goals : start.

  rswap 15 -13.  print_goals : swap1.

  rnorm. rnorm_unknown (u,w). print_goals : norm_uk1.
  rlet_abstract 2 gw g^w. print_goals : alet1.
  rlet_abstract 3 gu g^u. print_goals : alet2.
  rlet_abstract 4 gwu g^(w*u). 
  rddh v. print_goals : after_ddh.
  requiv
    [ w  <-$ Fq;
      u <-$ Fq;
      v <-$ Fq;
      x1 <-$ Fq;
      x2 <-$ Fq;
      y1 <-$ Fq;
      y2 <-$ Fq;
      z1 <-$ Fq;
      z2 <-$ Fq;
      (m0,m1) <- A1(g^(x1+w*x2),g^(y1+w*y2),g^(z1+w*z2),g^w);
      b <-$ Bool;
      let mb = (b?m0:m1);
      let sa  = g^u;
      let sa' = g^v;
      let sc  = mb * g^(u*z1 + v*z2);
      let sd  = g^(u*x1 + v*x2) * g^(y1*u*H(sa,sa',sc) + y2*v*H(sa,sa',sc));
      b' <- A2(sa,sa',sc,sd) with
        Dec(a,a',c,d) =
          [ c * (a^z1 * a'^z2)^(-1)
          | not (a = sa), not(a' = sa'), not(c = sc), not(d = sd),
            d = a^(x1+H(a,a',c)*y1) * a'^(x2+H(a,a',c)*y2) ];
    ] : b = b'. print_goals : equiv.

  (* We first perform a step based on statistical distance where we
     replace 'v <-$ Fq' by 'v <-$ Fq \ u*w'
  *)
  prove
    [ w  <-$ Fq;
      u <-$ Fq;
      v <-$ Fq \ u*w;
      x1 <-$ Fq;
      x2 <-$ Fq;
      y1 <-$ Fq;
      y2 <-$ Fq;
      z1 <-$ Fq;
      z2 <-$ Fq;
      (m0,m1) <- A1(g^(x1+w*x2),g^(y1+w*y2),g^(z1+w*z2),g^w);
      b <-$ Bool;
      let mb = (b?m0:m1);
      let sa  = g^u;
      let sa' = g^v;
      let sc  = mb * g^(u*z1 + v*z2);
      let sd  = g^(u*x1 + v*x2) * g^(y1*u*H(sa,sa',sc) + y2*v*H(sa,sa',sc));
      b' <- A2(sa,sa',sc,sd) with
        Dec(a,a',c,d) =
          [ c * (a^z1 * a'^z2)^(-1)
          | not (a = sa), not(a' = sa'), not(c = sc), not(d = sd),
            d = a^(x1+H(a,a',c)*y1) * a'^(x2+H(a,a',c)*y2) ];
    ] : b' = b. print_goals : equiv.

  (* We add the test @a^w = a'@ to the decryption oracle.
     In goal_1, we continue with the strengthened test.
     In goal_2, the test is strengthened and the adversary must
     return bad (a,a',c,d) where the old test succeeds, but
     a^w <>  a'.
     *)
  prove
    [ w  <-$ Fq;
      u <-$ Fq;
      v <-$ Fq \ u*w;
      x1 <-$ Fq;
      x2 <-$ Fq;
      y1 <-$ Fq;
      y2 <-$ Fq;
      z1 <-$ Fq;
      z2 <-$ Fq;
      (m0,m1) <- A1(g^(x1+w*x2),g^(y1+w*y2),g^(z1+w*z2),g^w);
      b <-$ Bool;
      let mb = (b?m0:m1);
      let sa  = g^u;
      let sa' = g^v;
      let sc  = mb * g^(u*z1 + v*z2);
      let sd  = g^(u*x1 + v*x2) * g^(y1*u*H(sa,sa',sc) + y2*v*H(sa,sa',sc));
      b' <- A2(sa,sa',sc,sd) with
        Dec(a,a',c,d) =
          [ c * (a^z1 * a'^z2)^(-1)
          | not (a = sa), not(a' = sa'), not(c = sc), not(d = sd),
            a^w = a',
            d = a^(x1+H(a,a',c)*y1) * a'^(x2+H(a,a',c)*y2) ];
    ] : b = b'. print_goals : goal_1.

  (* equivalent test, we exploit the identity a^w = a'. *)
  prove
    [ w  <-$ Fq;
      u <-$ Fq;
      v <-$ Fq \ u*w;
      x1 <-$ Fq;
      x2 <-$ Fq;
      y1 <-$ Fq;
      y2 <-$ Fq;
      z1 <-$ Fq;
      z2 <-$ Fq;
      (m0,m1) <- A1(g^(x1+w*x2),g^(y1+w*y2),g^(z1+w*z2),g^w);
      b <-$ Bool;
      let mb = (b?m0:m1);
      let sa  = g^u;
      let sa' = g^v;
      let sc  = mb * g^(u*z1 + v*z2);
      let sd  = g^(u*x1 + v*x2) * g^(y1*u*H(sa,sa',sc) + y2*v*H(sa,sa',sc));
      b' <- A2(sa,sa',sc,sd) with
        Dec(a,a',c,d) =
          [ c * (a^(z1 + w*z2))^(-1)
          | not (a = sa), not(a' = sa'), not(c = sc), not(d = sd),
            a^w = a',
            d = (a^(x1+H(a,a',c)*y1 + w*(x2+H(a,a',c)*y2))) ];
    ] : b = b'. print_goals : goal_1_1.

  (* We want to make 'u*z1 + v*z2' random independent of the remaining
     exponents since this would allow us to get rid of mb in the next step.
     Note that we cannot, apply random to u and v since both occur on their
     own. So we try to apply random to z1 and z2.
     We get the following exponents involving the two:
     
     z1   + w*z2
     u*z1 + v*z2

     We want to make
        z1   + w*z2 = z1_new
        u*z1 + v*z2 = z2_new
     =>  z1 = z1_new - w*z2 and after replacing in the second equation, we get
         u*z1_new - u*w*z2 + v*z2 = z2_new
     ==> z2 = (z2_new - u * z1_new) / (v - u*w)

     ==> we must sample v from Fq \ {u*w}
     *)
     rswap 8 1.
     rrandom 9 _ (y -> y + w*z2) zz. rlet_unfold 10.
     rnorm_nounfold. rswap 8 4.  print_goals : rand_z1.
     rrandom 12 _
                (y -> u*z1 + (v-u*w)*y + log(mb)) zzz.
     rlet_unfold 13. rlet_unfold 11. rnorm_nounfold. rswap 10 6. print_goals : rand_z1.
     rindep. print_goals : goal1_finished.

(* goal_2: we have guessed the bad query and performed a reduction
   such that a new adversary call A3 returns the bad values directly *)
adversary A3 : () -> (G * G * G *G).

  prove
    [ w  <-$ Fq;
      u <-$ Fq;
      v <-$ Fq \ u*w;
      x1 <-$ Fq;
      x2 <-$ Fq;
      y1 <-$ Fq;
      y2 <-$ Fq;
      z1 <-$ Fq;
      z2 <-$ Fq;
      (m0,m1) <- A1(g^(x1+w*x2),g^(y1+w*y2),g^(z1+w*z2),g^w);
      b <-$ Bool;
      let mb = (b?m0:m1);
      let sa  = g^u;
      let sa' = g^v;
      let sc  = mb * g^(u*z1 + v*z2);
      let sd  = g^(u*x1 + v*x2) * g^(y1*u*H(sa,sa',sc) + y2*v*H(sa,sa',sc));
      b' <- A2(sa,sa',sc,sd) with
        Dec(a,a',c,d) =
          [ c * (a^z1 * a'^z2)^(-1)
          | not (a = sa), not(a' = sa'), not(c = sc), not(d = sd),
            a^w = a',
            d = a^(x1+H(a,a',c)*y1) * a'^(x2+H(a,a',c)*y2) ];
      (ba,ba',bc,bd) <- A3();
    ] : not(ba^w = ba')
        /\ not (ba = sa) /\ not(ba' = sa') /\ not(bc = sc) /\ not(bd = sd)
        /\ (bd = (ba^(x1+H(ba,ba',bc)*y1) * ba'^(x2+H(ba,ba',bc)*y2))).
    print_goals : goal_2.
  (* we rewrite the test to exploit the equality *)
  prove
    [ w  <-$ Fq;
      u <-$ Fq;
      v <-$ Fq \ u*w;
      x1 <-$ Fq;
      x2 <-$ Fq;
      y1 <-$ Fq;
      y2 <-$ Fq;
      z1 <-$ Fq;
      z2 <-$ Fq;
      (m0,m1) <- A1(g^(x1+w*x2),g^(y1+w*y2),g^(z1+w*z2),g^w);
      b <-$ Bool;
      let mb = (b?m0:m1);
      let sa  = g^u;
      let sa' = g^v;
      let sc  = mb * g^(u*z1 + v*z2);
      let sd  = g^(u*x1 + v*x2) * g^(y1*u*H(sa,sa',sc) + y2*v*H(sa,sa',sc));
      b' <- A2(sa,sa',sc,sd) with
        Dec(a,a',c,d) =
          [ c * (a^(z1 + w*z2))^(-1)
          | not (a = sa), not(a' = sa'), not(c = sc), not(d = sd),
            a^w = a',
            d = a^(x1+H(a,a',c)*y1 + w*(x2+H(a,a',c)*y2)) ];
      (ba,ba',bc,bd) <- A3();
    ] : not(ba^w = ba')
        /\ not (ba = sa) /\ not(ba' = sa') /\ not(bc = sc) /\ not(bd = sd)
        /\ (bd = (ba^(x1+H(ba,ba',bc)*y1) * ba'^(x2+H(ba,ba',bc)*y2))).
    print_goals : goal_2_.
    
    (* we rewrite the expressions in the decryption a bit to reuse other exponents *)
    requiv
    [ w  <-$ Fq;
      u <-$ Fq;
      v <-$ Fq \ u*w;
      x1 <-$ Fq;
      x2 <-$ Fq;
      y1 <-$ Fq;
      y2 <-$ Fq;
      z1 <-$ Fq;
      z2 <-$ Fq;
      (m0,m1) <- A1(g^(x1+w*x2),g^(y1+w*y2),g^(z1+w*z2),g^w);
      b <-$ Bool;
      let mb = (b?m0:m1);
      let sa  = g^u;
      let sa' = g^v;
      let sc  = mb * g^(u*z1 + v*z2);
      let sd  = g^(u*x1 + v*x2+H(sa,sa',sc)*(y1*u + y2*v)); (* changed *)
      b' <- A2(sa,sa',sc,sd) with
        Dec(a,a',c,d) =
          [ c * (a^(z1 + w*z2))^(-1)
          | not (a = sa), not(a' = sa'), not(c = sc), not(d = sd),
            a^w = a',
            d = a^(x1 + w*x2 + H(a,a',c)*(y1 + w * y2)) ]; (* changed *) (* change *)
      (ba,ba',bc,bd) <- A3();
    ] : not(g^(log(ba)*w) = g^(log(ba')))           (* equivalent to log(ba) * w <> log(ba') *)
        /\ not (ba = sa) /\ not(ba' = sa') /\ not(bc = sc) /\ not(bd = sd)
        /\ (bd = (g^(   log(ba) *x1 + log(ba) *H(ba,ba',bc)*y1
                      + log(ba')*x2 + log(ba')*H(ba,ba',bc)*y2))). (* changed*)
    print_goals : goal_2_.
    rswap 4 1. rrandom 5 _ (y -> y + w*x2) uuu. rlet_unfold 6. rnorm_nounfold. print_goals : ttt.
    rswap 6 1. rrandom 7 _ (y -> y + w*y2) uuuu. rlet_unfold 8. rnorm_nounfold. print_goals : tttt.
    rswap 4 11.
    rrandom 15 _ (y -> y*v + x1*u + -(w*y*u) + -(w*y2*u*H(sa, sa', sc)) + y2*v*H(sa, sa',sc) + y1*u*H(sa, sa', sc))
               uuuuuu.
    rlet_unfold 16. rnorm_nounfold. rswap 5 13.
    rlet_abstract 17 hs (H(sa, sa', sc)).
    rlet_abstract 18 hb (H(ba, ba', bc)).
    rlet_abstract 19 la (log(ba)).
    rlet_abstract 20 la' (log(ba')).
    print_goals : aads.
    rnorm_nounfold.
    rlet_abstract 22 mz
    ((   u*w*w*y2*la*hs
        - (u*w*w*y2*la*hb)
        - (u*w*y2*la'*hs)
        + u*w*y2*la'*hb
        - (u*w*y1*la*hs)
        + u*w*y1*la*hb
        + u*x1*la'
        + u*y1*la'*hs
        + w*x2*la
        - (w*y2*v*la*hs)
        + w*y2*v*la*hb
        - (x2*la')
        - (x1*v*la) 
        + y2*v*la'*hs
        - (y2*v*la'*hb)
        - (y1*v*la*hb))
     / (u*w + -v)).
    print_goals : try_TRYIT.
    rrandom 22 _
    (r ->
      (   u*w*w*r*la*hs
        - (u*w*w*r*la*hb)
        - (u*w*r*la'*hs)
        + u*w*r*la'*hb
        - (u*w*y1*la*hs)
        + u*w*y1*la*hb
        + u*x1*la'
        + u*y1*la'*hs
        + w*x2*la
        - (w*r*v*la*hs)
        + w*r*v*la*hb
        - (x2*la')
        - (x1*v*la) 
        + r*v*la'*hs
        - (r*v*la'*hb)
        - (y1*v*la*hb))
     / (u*w + -v)) muu.
     rnorm.
     print_goals : aadsd.
     (* cannot prove that
          u*w*w*hs*la + -(u*w*w*hb*la) + -(u*w*hs*la') + u*w*hb*la' + -(w*v*hs*la) + w*v*hb*la + v*hs*la' + -(v*hb*la')
        nonzero
        
        > ring R = (0,u,v,w,hs,hb,la,la'),(a),dp;
        > number f = u*w*w*hs*la + -(u*w*w*hb*la) + -(u*w*hs*la') + u*w*hb*la' + -(w*v*hs*la) + w*v*hb*la + v*hs*la' + -(v*hb*la');
        > f / (u*w - v);
        (w*hs*la-w*hb*la-hs*la'+hb*la')
        > f / (u*w - v*v);
        (u*w^2*hs*la-u*w^2*hb*la-u*w*hs*la'+u*w*hb*la'-v*w*hs*la+v*w*hb*la+v*hs*la'-v*hb*la')/(u*w-v^2)
        > f / (u*w - v);
        (w*hs*la-w*hb*la-hs*la'+hb*la')
        > f / ((u*w - v)*(hb - hs));
        (-w*la+la')
        > f / ((u*w - v)*(hb - hs)*(la'-w*la));
        1

        We could try trial division for all non-zeroness assumptions, i.e., divide and check if denominator
        of result is 1.
        For this, we need factored/atomic inequality constraints (note that f*g <> 0 <=> (f <> 0 \/ g <> 0), so they
        should be factored usually).
    *)

    (*
-(x1*v*la)
+ u*x1*la'
+ -(x2*la')
+ u*w*w*y2*hs*la
+ -(u*w*w*y2*hb*la)
+ -(u*w*y2*hs*la')
+ u*w*y2*hb*la'
+ -(u*w*y1*hs*la)
+ u*w*y1*hb*la
+ u*y1*hs*la'
+ -(w*y2*v*hs*la)
+ w*y2*v*hb*la
+ y2*v*hs*la'
+ -(y2*v*hb*la')
+ -(y1*v*hb*la))

(-(u*w*w*y2*la*hb) + u*w*y2*la'*hb + u*w*y1*la*hb + u*x1*la' + w*y2*v*la*hb + -(x2*la') + -(x1*v*la) + -(y2*v*la'*hb) + -(y1*v*la*hb) + u*w*w*y2*la*hs + -(u*w*y2*la'*hs) + -(u*w*y1*la*hs) + u*y1*la'*hs + -(w*y2*v*la*hs) + y2*v*la'*hs)

*)