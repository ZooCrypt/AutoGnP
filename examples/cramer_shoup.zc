adversary A1 : (G * G * G * G) -> (G * G).
adversary A2 : (G * G * G * G) -> Bool.
oracle Dec : (G * G * G * G) -> G.
(* not really  a random oracle, change this later *)
random oracle H : ( G * G * G) -> Fq.

prove
  [ w  <-$ Fq;
    x1 <-$ Fq;
    x2 <-$ Fq;
    y1 <-$ Fq;
    y2 <-$ Fq;
    z1 <-$ Fq;
    z2 <-$ Fq;
    let p1 = g^(x1+w*x2);
    let p2 = g^(y1+w*y2);
    let p3 = g^(z1+w*z2);
    let p4 = g^w;
    (m0,m1) <- A1(p1,p2,p3,p4);
    b <-$ Bool;
    let mb = (b?m0:m1);
    u <-$ Fq;
    let sa = g^u;
    let sa' = p4^u;
    let sc = mb * p3^u;
    let sd = p1^u * p2^(u*H(sa,sa',sc));
    b' <- A2(sa,sa',sc,sd) with
      Dec(a,a',c,d) =
        [ c * (a^z1 * a'^z2)^(-1)
        | not (a = sa), not(a' = sa'), not(c = sc), not(d = sd),
          d = a^(x1+H(a,a',c)*y1) * a'^(x2+H(a,a',c)*y2) ];
  ] : b = b'. print_goals : start.

  rswap 15 -13.  print_goals : swap1.

  rnorm. rnorm_unknown (u,w). print_goals : norm_uk1.
  rlet_abstract 2 gw g^w. print_goals : alet1.
  rlet_abstract 3 gu g^u. print_goals : alet2.
  rlet_abstract 4 gwu g^(w*u). 
  rddh v. print_goals : after_ddh.
  requiv
    [ w  <-$ Fq;
      u <-$ Fq;
      v <-$ Fq;
      x1 <-$ Fq;
      x2 <-$ Fq;
      y1 <-$ Fq;
      y2 <-$ Fq;
      z1 <-$ Fq;
      z2 <-$ Fq;
      (m0,m1) <- A1(g^(x1+w*x2),g^(y1+w*y2),g^(z1+w*z2),g^w);
      b <-$ Bool;
      let mb = (b?m0:m1);
      let sa  = g^u;
      let sa' = g^v;
      let sc  = mb * g^(u*z1 + v*z2);
      let sd  = g^(u*x1 + v*x2) * g^(y1*u*H(sa,sa',sc) + y2*v*H(sa,sa',sc));
      b' <- A2(sa,sa',sc,sd) with
        Dec(a,a',c,d) =
          [ c * (a^z1 * a'^z2)^(-1)
          | not (a = sa), not(a' = sa'), not(c = sc), not(d = sd),
            d = a^(x1+H(a,a',c)*y1) * a'^(x2+H(a,a',c)*y2) ];
    ] : b = b'.  print_goals : equiv.
    radd_test (17,1,5) (a^w  = a') A3 ba ba' bc bd. print_goals : added_test.
