adversary A1 : (G * G * G * G) -> (G * G).
adversary A2 : (G * G * G * G) -> Bool.
oracle Dec : (G * G * G * G) -> G.
(* not really a random oracle, change this later *)
random oracle H : (G * G * G) -> Fq.

prove
  [ w  <-$ Fq;
    x1 <-$ Fq;
    x2 <-$ Fq;
    y1 <-$ Fq;
    y2 <-$ Fq;
    z1 <-$ Fq;
    z2 <-$ Fq;
    let p1 = g^(x1+w*x2);
    let p2 = g^(y1+w*y2);
    let p3 = g^(z1+w*z2);
    let p4 = g^w;
    (m0,m1) <- A1(p1,p2,p3,p4);
    b <-$ Bool;
    let mb = (b?m0:m1);
    u <-$ Fq;
    let sa = g^u;
    let sa' = p4^u;
    let sc = mb * p3^u;
    let sd = p1^u * p2^(u*H(sa,sa',sc));
    b' <- A2(sa,sa',sc,sd) with
      Dec(a,a',c,d) =
        [ c * (a^z1 * a'^z2)^(-1)
        | not (a = sa), not(a' = sa'), not(c = sc), not(d = sd),
          d = a^(x1+H(a,a',c)*y1) * a'^(x2+H(a,a',c)*y2) ];
  ] : b = b'. print_goals : start.

  rswap 15 -13.  print_goals : swap1.

  rnorm. rnorm_unknown (u,w). print_goals : norm_uk1.
  rlet_abstract 2 gw g^w. print_goals : alet1.
  rlet_abstract 3 gu g^u. print_goals : alet2.
  rlet_abstract 4 gwu g^(w*u). 
  rddh v. print_goals : after_ddh.
  requiv
    [ w  <-$ Fq;
      u <-$ Fq;
      v <-$ Fq;
      x1 <-$ Fq;
      x2 <-$ Fq;
      y1 <-$ Fq;
      y2 <-$ Fq;
      z1 <-$ Fq;
      z2 <-$ Fq;
      (m0,m1) <- A1(g^(x1+w*x2),g^(y1+w*y2),g^(z1+w*z2),g^w);
      b <-$ Bool;
      let mb = (b?m0:m1);
      let sa  = g^u;
      let sa' = g^v;
      let sc  = mb * g^(u*z1 + v*z2);
      let sd  = g^(u*x1 + v*x2) * g^(y1*u*H(sa,sa',sc) + y2*v*H(sa,sa',sc));
      b' <- A2(sa,sa',sc,sd) with
        Dec(a,a',c,d) =
          [ c * (a^z1 * a'^z2)^(-1)
          | not (a = sa), not(a' = sa'), not(c = sc), not(d = sd),
            d = a^(x1+H(a,a',c)*y1) * a'^(x2+H(a,a',c)*y2) ];
    ] : b = b'. print_goals : equiv.

  (* We first perform a step based on statistical distance where we
     replace 'v <-$ Fq' by 'v <-$ Fq \ u*w'
  *)
  prove
    [ w  <-$ Fq;
      u <-$ Fq;
      v <-$ Fq \ u*w;
      x1 <-$ Fq;
      x2 <-$ Fq;
      y1 <-$ Fq;
      y2 <-$ Fq;
      z1 <-$ Fq;
      z2 <-$ Fq;
      (m0,m1) <- A1(g^(x1+w*x2),g^(y1+w*y2),g^(z1+w*z2),g^w);
      b <-$ Bool;
      let mb = (b?m0:m1);
      let sa  = g^u;
      let sa' = g^v;
      let sc  = mb * g^(u*z1 + v*z2);
      let sd  = g^(u*x1 + v*x2) * g^(y1*u*H(sa,sa',sc) + y2*v*H(sa,sa',sc));
      b' <- A2(sa,sa',sc,sd) with
        Dec(a,a',c,d) =
          [ c * (a^z1 * a'^z2)^(-1)
          | not (a = sa), not(a' = sa'), not(c = sc), not(d = sd),
            d = a^(x1+H(a,a',c)*y1) * a'^(x2+H(a,a',c)*y2) ];
    ] : b' = b. print_goals : equiv.

  (* We add the test @a^w = a'@ to the decryption oracle.
     In goal_1, we continue with the strengthened test.
     In goal_2, the test is strengthened and the adversary must
     return bad (a,a',c,d) where the old test succeeds, but
     a^w <>  a'.
     *)
  prove
    [ w  <-$ Fq;
      u <-$ Fq;
      v <-$ Fq \ u*w;
      x1 <-$ Fq;
      x2 <-$ Fq;
      y1 <-$ Fq;
      y2 <-$ Fq;
      z1 <-$ Fq;
      z2 <-$ Fq;
      (m0,m1) <- A1(g^(x1+w*x2),g^(y1+w*y2),g^(z1+w*z2),g^w);
      b <-$ Bool;
      let mb = (b?m0:m1);
      let sa  = g^u;
      let sa' = g^v;
      let sc  = mb * g^(u*z1 + v*z2);
      let sd  = g^(u*x1 + v*x2) * g^(y1*u*H(sa,sa',sc) + y2*v*H(sa,sa',sc));
      b' <- A2(sa,sa',sc,sd) with
        Dec(a,a',c,d) =
          [ c * (a^z1 * a'^z2)^(-1)
          | not (a = sa), not(a' = sa'), not(c = sc), not(d = sd),
            a^w = a',
            d = a^(x1+H(a,a',c)*y1) * a'^(x2+H(a,a',c)*y2) ];
    ] : b = b'. print_goals : goal_1.

  (* equivalent test, we exploit the identity a^w = a'. *)
  prove
    [ w  <-$ Fq;
      u <-$ Fq;
      v <-$ Fq \ u*w;
      x1 <-$ Fq;
      x2 <-$ Fq;
      y1 <-$ Fq;
      y2 <-$ Fq;
      z1 <-$ Fq;
      z2 <-$ Fq;
      (m0,m1) <- A1(g^(x1+w*x2),g^(y1+w*y2),g^(z1+w*z2),g^w);
      b <-$ Bool;
      let mb = (b?m0:m1);
      let sa  = g^u;
      let sa' = g^v;
      let sc  = mb * g^(u*z1 + v*z2);
      let sd  = g^(u*x1 + v*x2) * g^(y1*u*H(sa,sa',sc) + y2*v*H(sa,sa',sc));
      b' <- A2(sa,sa',sc,sd) with
        Dec(a,a',c,d) =
          [ c * (a^(z1 + w*z2))^(-1)
          | not (a = sa), not(a' = sa'), not(c = sc), not(d = sd),
            a^w = a',
            d = (a^(x1+H(a,a',c)*y1 + w*(x2+H(a,a',c)*y2))) ];
    ] : b = b'. print_goals : goal_1_1.

  (* We want to make 'u*z1 + v*z2' random independent of the remaining
     exponents since this would allow us to get rid of mb in the next step.
     Note that we cannot, apply random to u and v since both occur on their
     own. So we try to apply random to z1 and z2.
     We get the following exponents involving the two:
     
     z1   + w*z2
     u*z1 + v*z2

     We want to make
        z1   + w*z2 = z1_new
        u*z1 + v*z2 = z2_new
     =>  z1 = z1_new - w*z2 and after replacing in the second equation, we get
         u*z1_new - u*w*z2 + v*z2 = z2_new
     ==> z2 = (z2_new - u * z1_new) / (v - u*w)

     ==> we must sample v from Fq \ {u*w}
     *)
     rswap 8 1.
     rrandom 9 _ (y -> y + w*z2) zz. rlet_unfold 10.
     rnorm_nounfold. rswap 8 4.  print_goals : rand_z1.
     rrandom 12 _
                (y -> u*z1 + (v-u*w)*y + log(mb)) zzz.
     rlet_unfold 13. rlet_unfold 11. rnorm_nounfold. rswap 10 6. print_goals : rand_z1.
     rindep. print_goals : goal1_finished.

(* goal_2: we have guessed the bad query and performed a reduction
   such that a new adversary call A3 returns the bad values directly *)
adversary A3 : () -> (G * G * G *G).

  prove
    [ w  <-$ Fq;
      u <-$ Fq;
      v <-$ Fq \ u*w;
      x1 <-$ Fq;
      x2 <-$ Fq;
      y1 <-$ Fq;
      y2 <-$ Fq;
      z1 <-$ Fq;
      z2 <-$ Fq;
      (m0,m1) <- A1(g^(x1+w*x2),g^(y1+w*y2),g^(z1+w*z2),g^w);
      b <-$ Bool;
      let mb = (b?m0:m1);
      let sa  = g^u;
      let sa' = g^v;
      let sc  = mb * g^(u*z1 + v*z2);
      let sd  = g^(u*x1 + v*x2) * g^(y1*u*H(sa,sa',sc) + y2*v*H(sa,sa',sc));
      b' <- A2(sa,sa',sc,sd) with
        Dec(a,a',c,d) =
          [ c * (a^z1 * a'^z2)^(-1)
          | not (a = sa), not(a' = sa'), not(c = sc), not(d = sd),
            a^w = a',
            d = a^(x1+H(a,a',c)*y1) * a'^(x2+H(a,a',c)*y2) ];
      (ba,ba',bc,bd) <- A3();
    ] : not(ba^w = ba')
        /\ not (ba = sa) /\ not(ba' = sa') /\ not(bc = sc) /\ not(bd = sd)
        /\ (bd = (ba^(x1+H(ba,ba',bc)*y1) * ba'^(x2+H(ba,ba',bc)*y2))).
    print_goals : goal_2.
  (* we rewrite the test to exploit the equality *)
  prove
    [ w  <-$ Fq;
      u <-$ Fq;
      v <-$ Fq \ u*w;
      x1 <-$ Fq;
      x2 <-$ Fq;
      y1 <-$ Fq;
      y2 <-$ Fq;
      z1 <-$ Fq;
      z2 <-$ Fq;
      (m0,m1) <- A1(g^(x1+w*x2),g^(y1+w*y2),g^(z1+w*z2),g^w);
      b <-$ Bool;
      let mb = (b?m0:m1);
      let sa  = g^u;
      let sa' = g^v;
      let sc  = mb * g^(u*z1 + v*z2);
      let sd  = g^(u*x1 + v*x2) * g^(y1*u*H(sa,sa',sc) + y2*v*H(sa,sa',sc));
      b' <- A2(sa,sa',sc,sd) with
        Dec(a,a',c,d) =
          [ c * (a^(z1 + w*z2))^(-1)
          | not (a = sa), not(a' = sa'), not(c = sc), not(d = sd),
            a^w = a',
            d = a^(x1+H(a,a',c)*y1 + w*(x2+H(a,a',c)*y2)) ];
      (ba,ba',bc,bd) <- A3();
    ] : not(ba^w = ba')
        /\ not (ba = sa) /\ not(ba' = sa') /\ not(bc = sc) /\ not(bd = sd)
        /\ (bd = (ba^(x1+H(ba,ba',bc)*y1) * ba'^(x2+H(ba,ba',bc)*y2))).
    print_goals : goal_2_.
    
    (* we rewrite the expressions a bit in the decryption to reuse other exponents *)
    requiv
    [ w  <-$ Fq;
      u <-$ Fq;
      v <-$ Fq \ u*w;
      x1 <-$ Fq;
      x2 <-$ Fq;
      y1 <-$ Fq;
      y2 <-$ Fq;
      z1 <-$ Fq;
      z2 <-$ Fq;
      (m0,m1) <- A1(g^(x1+w*x2),g^(y1+w*y2),g^(z1+w*z2),g^w);
      b <-$ Bool;
      let mb = (b?m0:m1);
      let sa  = g^u;
      let sa' = g^v;
      let sc  = mb * g^(u*z1 + v*z2);
      let sd  = g^(u*x1 + v*x2+H(sa,sa',sc)*(y1*u + y2*v)); (* changed *)
      b' <- A2(sa,sa',sc,sd) with
        Dec(a,a',c,d) =
          [ c * (a^(z1 + w*z2))^(-1)
          | not (a = sa), not(a' = sa'), not(c = sc), not(d = sd),
            a^w = a',
            d = a^(x1 + w*x2 + H(a,a',c)*(y1 + w * y2)) ]; (* changed *) (* change *)
      (ba,ba',bc,bd) <- A3();
    ] : not(g^(log(ba)*w) = g^(log(ba')))           (* equivalent to log(ba) * w <> log(ba') *)
        /\ not (ba = sa) /\ not(ba' = sa') /\ not(bc = sc) /\ not(bd = sd)
        /\ (bd = (g^(   log(ba) *x1 + log(ba) *H(ba,ba',bc)*y1
                      + log(ba')*x2 + log(ba')*H(ba,ba',bc)*y2))). (* changed*)
    print_goals : goal_2_.
    rswap 4 1. rrandom 5 _ (y -> y + w*x2) uuu. rlet_unfold 6. rnorm_nounfold. print_goals : ttt.
    rswap 6 1. rrandom 7 _ (y -> y + w*y2) uuuu. rlet_unfold 8. rnorm_nounfold. print_goals : tttt.
    rswap 4 11.
    rrandom 15 _ (y -> y*v + x1*u + -(w*y*u) + -(w*y2*u*H(sa, sa', sc)) + y2*v*H(sa, sa',sc) + y1*u*H(sa, sa', sc))
               uuuuuu.
    rlet_unfold 16. rnorm_nounfold. print_goals : aads.
(*

log(bd) =
(   
y2*H(sa, sa', sc)
   (
    u*w*w*log(ba)
 -  u*w*w*log(ba)
 -  u*w*log(ba') 
 +  u*w*log(ba') 
 -  w*v*log(ba)  
 +  w*v*log(ba)  
 +  v*log(ba')   
 -  v*log(ba')
 )

 -  u*w*y1*log(ba)  *H(sa, sa', sc)
 +  u*w*y1*log(ba)  *H(ba, ba', bc)
 +  u*y1*log(ba')   *H(sa, sa', sc)
 -  y1*v*log(ba)    *H(ba, ba', bc)
 +  w*x2*log(ba)
 +  u*x1*log(ba') 
 -  x2*log(ba')
 -  x1*v*log(ba)
) / (u*w + -v)
*)

    (* We want to apply the random rule to make
         log(ba)*x1  + log(ba)*H(ba,ba',bc)*y1 + log(ba')*x2 + log(ba')*H(ba,ba',bc)*y2
       uniform independent of all other samplings since this allows us to directly bound the
       probability of the event using rindep.
       There are four random variables x1,x2,y1,y2 and they also occur in these other
       exponents:
       x1 + w*x2
       y1 + w*y2
       u*x1 + v*x2

       we therefore have to solve (using Hb = H(ba,ba',bc), Hs = H(sa,sa',sc),la = log(ba), and la' = log(ba')

       x1   x2      y1    y2      |
       ---------------------------|

       1    w       0      0      |  1  0  0  0  --| *(-u) -- *(-la)
       u    v       u*Hs   v*Hs   |  0  0  1  0 <--| +      |
       0    0       1      w      |  0  1  0  0             | 
       la   la'     la*Hb  la'*Hb |  0  0  0  1 <------------ +

       1   w          0     0      |  1    0  0  0
       0   v-uw       u*Hs  v*Hs   |  -u   0  1  0 <- * 1/(v-uw)       
       0   0          1     w      |  0    1  0  0
       0   la'-w*la   la*Hb la'*Hb |  -la  0  0  1

       1   w          0            0           |  1         0  0        0 
       0   1          u*Hs/(v-uw)  v*Hs/(v-uw) |  -u/(v-uw) 0  1/(v-uw) 0 <---------------|+
       0   0          1            w           |  0         1  0        0 --| *(-la*Hb) --|*(-u*Hs/(v-uw)
       0   la'-w*la   la*Hb        la'*Hb      |  -la       0  0        1 <-|+

       1   w          0    0              |  1         0             0        0 
       0   1          0    Hs             |  -u/(v-uw) -u*Hs/(v-uw)  1/(v-uw) 0 --| * (w*la -la')
       0   0          1    w              |  0         1             0        0   |   
       0   la'-w*la   0    (la'-w*la)*Hb  |  -la       -la*Hb        0        1 <-- +

       1   w   0  0                   |  1                         0                              0                    0 
       0   1   0  Hs                  |  -u/(v-uw)                 -u*Hs/(v-uw)                   1/(v-uw)             0
       0   0   1  w                   |  0                         1                              0                    0       
       0   0   0  (la'-w*la)*(Hb-Hs)  |  -la -u/(v-uw)*(w*la -la') -la*Hb-u*Hs/(v-uw)*(w*la -la') 1/(v-uw)*(w*la -la') 1

       write some code to perform matrix manipulations:
       1. start with initial matrix
       2. pivot 1,1
       3. pivot 3,3
       4. pivot 2,2
       5. pivot 4,4

       solve_matrix ((1,w,0,0),(u,v,u*Hs,v*Hs),(0,0,1,w),(la,la',la,Hb,la',Hb)) ((1,1),(3,3),(2,2),(4,4)).

       Idea:
       First handle x1 + w*x2, then y1 + w y2.
*)

