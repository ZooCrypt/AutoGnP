adversary A1 : (G * G * G * G) -> (G * G).
adversary A2 : (G * G * G * G) -> Bool.
oracle Dec : (G * G * G * G) -> G.
(* not really  a random oracle, change this later *)
random oracle H : ( G * G * G) -> Fq.
assumption ddh
  [ x <-$ Fq; y <-$ Fq;
    let gx = g ^ x; let gy = g ^ y; let gxy = g ^ (x * y); ]
  [ x <-$ Fq; y <-$ Fq; z <-$ Fq;
    let gx = g ^ x; let gy = g ^ y; let gxy = g ^ z; ]
    x y z.

prove
  [ w  <-$ Fq;
    x1 <-$ Fq;
    x2 <-$ Fq;
    y1 <-$ Fq;
    y2 <-$ Fq;
    z1 <-$ Fq;
    z2 <-$ Fq;
    let p1 = g^(x1+w*x2);
    let p2 = g^(y1+w*y2);
    let p3 = g^(z1+w*z2);
    let p4 = g^w;
    (m0,m1) <- A1(p1,p2,p3,p4);
    b <-$ Bool;
    let mb = (b?m0:m1);
    u <-$ Fq;
    let sa = g^u;
    let sa' = p4^u;
    let sc = mb * p3^u;
    let sd = p1^u * p2^(u*H(sa,sa',sc));
    b' <- A2(sa,sa',sc,sd) with
      Dec(a,a',c,d) =
        [ c * (a^z1 * a'^z2)^(-1)
        | not (a = sa), not(a' = sa'), not(c = sc), not(d = sd),
          d = a^(x1+H(a,a',c)*y1) * a'^(x2+H(a,a',c)*y2) ];
  ] : b = b'. print_goals : start.

(* apply DDH
     we try to bring the game into DDH-form for all pairs
     of distinct random variables.
     z1, z2, x1, x2, y1, y2 used in decryption as exponent
     ==> only u,v work
*)
  rswap 15 -13.
  rnorm. rnorm_unknown u w.
  rlet_abstract 2 gw g^w.
  rlet_abstract 3 gu g^u.
  rlet_abstract 4 gwu g^(w*u). 
  assumption -> ddh v. rnorm.

(* Perform "safe" applications of the random rule from start-of-main
   to end-of-main using the field-expression where the random
   variable occurs first as bijection and computing the inverse.
   Prefer applications where both contexts are division-free.
*)
  rswap 4 1. rrandom 5 _ (y -> w*x2 + y) l_x1. rnorm.
  rswap 6 1. rrandom 7 _ (y -> w*y2 + y) l_y1. rnorm.
  rswap 8 1. rrandom 9 _ (y -> w*z2 + y) l_z1. rnorm.
  rswap 4 7. rswap 5 6. rswap 6 3.

(* If we try to apply rrandom to z2, we notice that the inequality
   'u*w <> v' is required. We therefore make the sampling of v
   excepted.
*)
  rexcept 3 u*w.
  rrandom 9 _ (y -> z1*u + y*v + log(b?m0:m1) - w*y*u) l_z2. rnorm.

(* The two remaining random variables to which we could apply rrandom are x2 and y2:
    x2 has coefficient (v - u*w), y2 has coefficient H(g^u, g^v, g^z2)*...,
    in the first exponent, so we pick x2 since (v -u*w) is nonzero. *)
  rswap 10 1.
  rrandom 11 _ (y -> x1*u + y*v - w*y*u - w*y2*u*H(g^u,g^v,g^z2) +
                     y1*u*H(g^u,g^v,g^z2) + y2*v*H(g^u,g^v,g^z2)) r_x2. rnorm.

(* We notice that input to hash function is completely random now,
   we can add a test to Dec because the bad case can be discharged
   using TCR later on.
*)
  radd_test (12,1,4) (not (H(a,a',c) = H(g^u, g^v,g^z2))) A3 ba ba' bc bd.

(* We first focus on the bad case:
   For a reduction to TCR, we u,v,z2 must be uniformly sampled.
   We therefore first remove the excepted distribution transformer from 
   the sampling of v.
*)
  last.
  print_goals : l1.
  rexcept 3.
  print_goals : l2.
  rswap 2 -1.
  print_goals : l3.
  rswap 3 -1.
  print_goals : l4.    
  rswap 9 -6.
  rlet_abstract 4 hin (g^u, g^v, g^z2).
  print_goals : tcr_admit.
  admit. (* this is TCR *)

  (* There is still a problem because we use the plug-and-pray bad
     rule, but want to use the list-rule here because we reduce
     to a compute-assumption *)

(* We now add the user-provided validity check "a^w = a'" in Dec.
   Why now?
   EITHER because we tried to add the test before every
   earlier step and had to backtrack
   OR because we are stuck now.
*)
  radd_test (12,1,6) (a^w  = a') A3' ga ga' gc gd.
  rnorm.

(* We have a test of the form "var = expr".
   We always rewrite with such tests.
*)
  rrewrite_oracle (12,1,1) <-. rnorm.
  rswap 8 4. rindep.

(* We have a test of the form "var = expr".
   We always rewrite with such tests.
*)
  rrewrite_oracle (12,1,1) <-. rnorm.
  print_goals : before_let_abstract.
  rlet_abstract 13 l log(ga).
  rlet_abstract 13 hc H(g^u,g^v,g^z2).
  rlet_abstract 13 hb H(ga, ga', gc).
  rswap 10 6.
  rctxt_ev
    (q -> (log(q) * (w*u -v) - w*x2*l + (x1*v*l) -(x2*log(ga'))
           - x1*u*log(ga') - w*y1*u*l*hb + (y1*v*l*hb) + (w*y1*u*l*hc) - y1*u*log(ga')*hc + (x2*log(ga')*2))
          /
          (-(w*w*u*l*hb) + w*u*log(ga')*hb + w*v*l*hb + -(v*log(ga')*hb) + w*w*u*l*hc +
          -(w*u*log(ga')*hc) + -(w*v*l*hc) + v*log(ga')*hc))
    6.
  rlet_unfold 15.
  print_goals : rewrite_bad.  
  rnorm_nounfold.
  rindep.
  print_goals : after_indep.