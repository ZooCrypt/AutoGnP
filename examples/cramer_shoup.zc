adversary A1 : (G * G * G * G) -> (G * G).
adversary A2 : (G * G * G * G) -> Bool.
oracle Dec : (G * G * G * G) -> G.

operator H : ( G * G * G) -> Fq.

assumption_decisional ddh
  [ x <-$ Fq; y <-$ Fq;
    let gx = g ^ x; let gy = g ^ y; let gxy = g ^ (x * y); ]
  [ x <-$ Fq; y <-$ Fq; z <-$ Fq;
    let gx = g ^ x; let gy = g ^ y; let gxy = g ^ z; ]
    x y z.

assumption_computational tcr
  [ a <-$ Fq; b <-$ Fq; c <-$ Fq;
    let ga = g ^ a; let gb = g ^ b; let gc = g ^ c; ]
  (x : (G * G * G) -> (H(x) = H(ga,gb,gc)) /\ not (x = (ga,gb,gc)) )
  a b c.

prove
  [ w  <-$ Fq;
    x1 <-$ Fq;
    x2 <-$ Fq;
    y1 <-$ Fq;
    y2 <-$ Fq;
    z1 <-$ Fq;
    z2 <-$ Fq;
    let p1 = g^(x1+w*x2);
    let p2 = g^(y1+w*y2);
    let p3 = g^(z1+w*z2);
    let p4 = g^w;
    (m0,m1) <- A1(p1,p2,p3,p4);
    b <-$ Bool;
    let mb = (b?m0:m1);
    u <-$ Fq;
    let sa = g^u;
    let sa' = p4^u;
    let sc = mb * p3^u;
    let sd = p1^u * p2^(u*H(sa,sa',sc));
    b' <- A2(sa,sa',sc,sd) with
      Dec(a,a',c,d) =
        [ c * (a^z1 * a'^z2)^(-1)
        | not ((a,a',c,d) = (sa,sa',sc,sd)),
          d = a^(x1+H(a,a',c)*y1) * a'^(x2+H(a,a',c)*y2) ];
  ] : b = b'.

(* we could sample here, but then we cannot perform DDH *)
(*
  rrandom 2 _ _ tmp.
  rrandom 4 _ _ tmp.
  rrandom 6 _ _ tmp.
*)

(* apply DDH
     we try to bring the game into DDH-form for all pairs
     of distinct random variables.
     z1, z2, x1, x2, y1, y2 used in decryption as exponent
     ==> only u,v work
*)
  rswap 15 -13.
  rnorm. rnorm_unknown u w.
  rlet_abstract 3 gw g^w.
  rlet_abstract 4 gu g^u.
  rlet_abstract 5 gwu g^(w*u).
  assumption_decisional -> ddh v. rnorm.

(* perform rrandom for samplings of random variables r starting from the first line,
   skip lines for which r occurs on its own somewhere else and delay lines where
   inequality (enforced by excepted sampling) is required *)
  (* lines 1 - 3: random variables occur on their own somewhere else *)
  rrandom 4 _ _ tmp. (* line 5/x2 requires w*u + -v <> 0 *)
  rrandom 6 _ _ tmp. (* line 7/y2 requires that complicated expression <> 0 *)
  rrandom 8 _ _ tmp. (* line 9/z requires w*u + -v <> 0 *)

(* No we add the simpler inequality and continue randomizing *)
  rexcept 3 u*w.
  rrandom 5 _ _ tmp.
  rrandom 9 _ _ tmp.

(* We notice that input to hash function is completely random now,
   we can add a test to Dec because the bad case can be discharged
   using TCR later on.
*)
  radd_test (12,1,2) (not (H(a,a',c) = H(g^u, g^v,g^z2))) A3 ba ba' bc bd.

(* We first focus on the bad case:
   For a reduction to TCR, the inputs u,v,z2 must be uniformly sampled.
   We therefore first remove the excepted distribution transformer from 
   the sampling of v.
*)
  last.
  (* adapt the event to get the right inequality *)
  rcase_ev ((ba,ba',bc) = (g^u,g^v,g^z2)). rnorm.
  rsplit_ev 4.
  rrewrite_ev 4 ->.
  rrewrite_ev 5 ->.
  rrewrite_ev 6 ->.
  rnorm.
  rrewrite_ev 3 ->.
  rnorm.
  rfalse_ev.
  
  rremove_ev 1. rremove_ev 1.
  
  radd_test (12,1,3) (a^w  = a') A4 ga ga' gc gd.
  rnorm.

  (* We have a test of the form "var = expr".
     We always rewrite with such tests.
  *)
  rrewrite_oracle (12,1,1) <-. rnorm.
  rnorm_unknown u v z2.
  rswap 2 -1.
  rexcept 3.
  rswap 3 -1.
  rswap 9 -6.
  rlet_abstract 4 tu g^u.
  rlet_abstract 5 tv g^v.
  rlet_abstract 6 tz g^z2.
  assumption_computational tcr (ba,ba',bc).

(* We have a test of the form "var = expr".
   We always rewrite with such tests.
*)
  rrewrite_oracle (12,1,1) <-. rindep.

(* We now add the user-provided validity check "a^w = a'" in Dec.
   Why now?
   EITHER because we tried to add the test before every
   earlier step and had to backtrack
   OR because we are stuck now.
*)
  radd_test (12,1,3) (a^w  = a') A5 ga ga' gc gd.
  rnorm.

(* We have a test of the form "var = expr".
   We always rewrite with such tests.
*)
  rrewrite_oracle (12,1,1) <-. rindep.

(* We have a test of the form "var = expr".
   We always rewrite with such tests.
*)
  rrewrite_oracle (12,1,1) <-. rindep.

  extract "cramer_shoup.ec".