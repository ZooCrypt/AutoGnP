adversary A1 : (G * G * G * G) -> (G * G).
adversary A2 : (G * G * G * G) -> Bool.
oracle Dec : (G * G * G * G) -> G.

operator H : ( G * G * G) -> Fq.

assumption_decisional ddh
  [ x <-$ Fq; y <-$ Fq;
    let gx = g ^ x; let gy = g ^ y; let gxy = g ^ (x * y); ]
  [ x <-$ Fq; y <-$ Fq; z <-$ Fq;
    let gx = g ^ x; let gy = g ^ y; let gxy = g ^ z; ]
    x y z.

assumption_computational tcr
  [ a <-$ Fq; b <-$ Fq; c <-$ Fq;
    let ga = g ^ a; let gb = g ^ b; let gc = g ^ c; ]
  (x : (G * G * G) -> (H(x) = H(ga,gb,gc)) /\ not (x = (ga,gb,gc)) )
  a b c.

prove
  [ w  <-$ Fq;
    x1 <-$ Fq;
    x2 <-$ Fq;
    y1 <-$ Fq;
    y2 <-$ Fq;
    z1 <-$ Fq;
    z2 <-$ Fq;
    let p1 = g^(x1+w*x2);
    let p2 = g^(y1+w*y2);
    let p3 = g^(z1+w*z2);
    let p4 = g^w;
    (m0,m1) <- A1(p1,p2,p3,p4);
    b <-$ Bool;
    let mb = (b?m0:m1);
    u <-$ Fq;
    let sa = g^u;
    let sa' = p4^u;
    let sc = mb * p3^u;
    let sd = p1^u * p2^(u*H(sa,sa',sc));
    b' <- A2(sa,sa',sc,sd) with
      Dec(a,a',c,d) =
        [ c * (a^z1 * a'^z2)^(-1)
        | not ((a,a',c,d) = (sa,sa',sc,sd)),
          d = a^(x1+H(a,a',c)*y1) * a'^(x2+H(a,a',c)*y2) ];
  ] : b = b'.

(* apply DDH
     we try to bring the game into DDH-form for all pairs
     of distinct random variables.
     z1, z2, x1, x2, y1, y2 used in decryption as exponent
     ==> only u,v work
*)
  rswap 15 -13.
  rnorm. rnorm_unknown u w.
  rlet_abstract 3 gw g^w.
  rlet_abstract 4 gu g^u.
  rlet_abstract 5 gwu g^(w*u).
  assumption_decisional -> ddh v. rnorm.

(* Perform "safe" applications of the random rule from start-of-main
   to end-of-main using the field-expression where the random
   variable occurs first as bijection and computing the inverse.
   Prefer applications where both contexts are division-free.
*)
  (* make g ^ (w*x2 + x1) random using x1 / _ - x1 does not require division *)
  rswap 4 1. rrandom 5 _ (y -> w*x2 + y) tmp. rnorm.
    (* support _ in second position:
       let x1 random variable in line 5,
       list of terms in gdef,
       find first field_expressions fe that contains x1 (in outermost field context),
       use (x1 -> fe)
       move everything before so that bijection defined
    *)
  rswap 6 1. rrandom 7 _ (y -> w*y2 + y) tmp. rnorm.
  rswap 8 1. rrandom 9 _ (y -> w*z2 + y) tmp. rnorm.
  rswap 4 7. rswap 5 6. rswap 6 3.

(* If we try to apply rrandom to z2, we notice that the inequality
   'u*w <> v' is required. We therefore make the sampling of v
   excepted.
*)
  rexcept 3 u*w.
  rrandom 9 _ (y -> z1*u + y*v + log(b?m0:m1) - w*y*u) tmp. rnorm.

(* The two remaining random variables to which we could apply rrandom are x2 and y2:
    x2 has coefficient (v - u*w), y2 has coefficient H(g^u, g^v, g^z2)*...,
    in the first exponent, so we pick x2 since (v - u*w) is nonzero. *)
  rswap 10 1.
  rrandom 11 _ (y -> x1*u + y*v - w*y*u - w*y2*u*H(g^u,g^v,g^z2) +
                     y1*u*H(g^u,g^v,g^z2) + y2*v*H(g^u,g^v,g^z2)) r_x2. rnorm.

(* We notice that input to hash function is completely random now,
   we can add a test to Dec because the bad case can be discharged
   using TCR later on.
*)
  radd_test (12,1,2) (not (H(a,a',c) = H(g^u, g^v,g^z2))) A3 ba ba' bc bd.

(* We first focus on the bad case:
   For a reduction to TCR, the inputs u,v,z2 must be uniformly sampled.
   We therefore first remove the excepted distribution transformer from 
   the sampling of v.
*)
  last.
  (* adapt the event to get the right inequality *)
  rcase_ev ((ba,ba',bc) = (g^u,g^v,g^z2)). rnorm.
  rsplit_ev 4.
  rrewrite_ev 4 ->.
  rrewrite_ev 5 ->.
  rrewrite_ev 6 ->.
  rnorm.
  rrewrite_ev 3 ->.
  rnorm.
  rfalse_ev.
  
  rremove_ev 1. rremove_ev 1.
  
  radd_test (12,1,3) (a^w  = a') A4 ga ga' gc gd.
  rnorm.

  (* We have a test of the form "var = expr".
     We always rewrite with such tests.
  *)
  rrewrite_oracle (12,1,1) <-. rnorm.
  rnorm_unknown u v z2.
  rswap 2 -1.
  rexcept 3.
  rswap 3 -1.
  rswap 9 -6.
  rlet_abstract 4 tu g^u.
  rlet_abstract 5 tv g^v.
  rlet_abstract 6 tz g^z2.
  assumption_computational tcr (ba,ba',bc).

(* We have a test of the form "var = expr".
   We always rewrite with such tests.
*)
  rrewrite_oracle (12,1,1) <-. rnorm.
  rlet_abstract 14 l log(ga).
  rlet_abstract 14 hc H(g^u,g^v,g^z2).
  rlet_abstract 14 hb H(ga, ga', gc).
  rswap 10 6.
  rctxt_ev (qq -> log(qq)) 3.
  rnorm_nounfold.
  rctxt_ev
    (r -> (r * (w*u -v) - w*x2*l + (x1*v*l) -(x2*log(ga'))
           - x1*u*log(ga') - w*y1*u*l*hb + (y1*v*l*hb) + (w*y1*u*l*hc) - y1*u*log(ga')*hc + (x2*log(ga')*2))
          /
          (-(w*w*u*l*hb) + w*u*log(ga')*hb + w*v*l*hb + -(v*log(ga')*hb) + w*w*u*l*hc +
          -(w*u*log(ga')*hc) + -(w*v*l*hc) + v*log(ga')*hc))
    3.
  rlet_unfold 15.
  rnorm_nounfold.
  rindep.

(* We now add the user-provided validity check "a^w = a'" in Dec.
   Why now?
   EITHER because we tried to add the test before every
   earlier step and had to backtrack
   OR because we are stuck now.
*)
  radd_test (12,1,3) (a^w  = a') A5 ga ga' gc gd.
  rnorm.

(* We have a test of the form "var = expr".
   We always rewrite with such tests.
*)
  rrewrite_oracle (12,1,1) <-. rnorm.
  rswap 8 4. rindep.

(* We have a test of the form "var = expr".
   We always rewrite with such tests.
*)
  rrewrite_oracle (12,1,1) <-. rnorm.
  rlet_abstract 14 l log(ga).
  rlet_abstract 14 hc H(g^u,g^v,g^z2).
  rlet_abstract 14 hb H(ga, ga', gc).
  rswap 10 6.
  rctxt_ev (q -> log(q)) 3.
  rnorm_nounfold.
  rctxt_ev
    (r -> (r * (w*u -v) - w*x2*l + (x1*v*l) -(x2*log(ga'))
           - x1*u*log(ga') - w*y1*u*l*hb + (y1*v*l*hb) + (w*y1*u*l*hc) - y1*u*log(ga')*hc + (x2*log(ga')*2))
          /
          (-(w*w*u*l*hb) + w*u*log(ga')*hb + w*v*l*hb + -(v*log(ga')*hb) + w*w*u*l*hc +
          -(w*u*log(ga')*hc) + -(w*v*l*hc) + v*log(ga')*hc))
    3.
  rlet_unfold 15.
  rnorm_nounfold.
  rindep.
  
  extract "cramer_shoup.ec".