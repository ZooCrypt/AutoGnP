adversary A1 : (G * G * G * G) -> (G * G).
adversary A2 : (G * G * G * G) -> Bool.
oracle Dec1 : (G * G * G * G) -> G.
oracle Dec2 : (G * G * G * G) -> G.

operator H : ( G * G * G) -> Fq.

assumption_decisional ddh
  [ x <-$ Fq; y <-$ Fq;
    let gx = g ^ x; let gy = g ^ y; let gxy = g ^ (x * y); ]
  [ x <-$ Fq; y <-$ Fq; z <-$ Fq;
    let gx = g ^ x; let gy = g ^ y; let gxy = g ^ z; ]
    x y z.

assumption_computational tcr
  [ a <-$ Fq; b <-$ Fq; c <-$ Fq;
    let ga = g ^ a; let gb = g ^ b; let gc = g ^ c; ]
  (x : (G * G * G) -> (H(x) = H(ga,gb,gc)) /\ not (x = (ga,gb,gc)) )
  a b c.

prove
  [ w  <-$ Fq;
    x1 <-$ Fq;
    x2 <-$ Fq;
    y1 <-$ Fq;
    y2 <-$ Fq;
    z1 <-$ Fq;
    z2 <-$ Fq;
    (* secret key is x1,x2,y1,y2,z1,z2 *)
    let p1 = g^(x1+w*x2);
    let p2 = g^(y1+w*y2);
    let p3 = g^(z1+w*z2);
    let p4 = g^w;
    
    (m0,m1) <- A1(p1,p2,p3,p4) with
      Dec1(a,a',c,d) =
        [ c * (a^z1 * a' ^z2)^(-1)
        | d = a^(x1+H(a,a',c)*y1) * a'^(x2+H(a,a',c)*y2) ];

    b <-$ Bool;
    let mb = (b?m0:m1);
    (* randomness for encryption is u *)
    u <-$ Fq;
    (* we break the connection between sa' and the rest using DDH *)
    (* sc and sa are required for decryption *)
    let sa  = g^u;
    let sa' = p4^u;
    let sc  = mb * p3^u;
    let sd  = p1^u * p2^(u*H(sa,sa',sc));

    b' <- A2(sa,sa',sc,sd) with
      Dec2(a,a',c,d) =
        [ c * (a^z1 * a'^z2)^(-1)
        | not ((a,a',c,d) = (sa,sa',sc,sd)),
          d = a^(x1+H(a,a',c)*y1) * a'^(x2+H(a,a',c)*y2) ];

  ] : b = b'.

  (*
  ddh.
  rrandom*.
  rindep_progress. closes current goal, generates a new subgoal for test a^w = a'
  rindep.
  try rindep with Require(i) -> find_tactic(i). last. rindep.
  rindep_progress. closes current goal, generates a new subgoal for h(x) = h(y)
  tcr.
  *)

  (* we could sample here, but then we cannot perform DDH *)

  (* apply DDH *)
  rswap 15 -13. rnorm. rnorm_unknown u w.
  rlet_abstract 3 gw g^w. rlet_abstract 4 gu g^u. rlet_abstract 5 gwu g^(w*u).
  assumption_decisional -> ddh v. rnorm. (* assumption DDH *)

  (* perform all possible rrandom applications *)
  rexcept 3 u*w. rrandom 4 _ _. rrandom 6 _ _. rrandom 8 _ _.
  
  (* if a^w = a' for all queries, b not used in game anymore *)
  radd_test (10,1,1) (a^w = a') A3 ga ga' gc gd.
    rrewrite_oracle (10,1,1) <-. rnorm.
    rswap 5 6.
    rindep.
  rrewrite_oracle (10,1,1) <-. rnorm.
  rrandom 5 _ _.
  rrandom 9 _ _.
  
  radd_test (12,1,2) (a^w = a') A4 ea ea' ec ed.
    last. rrewrite_oracle (12,1,1) <-. rnorm. rindep.
  rrewrite_oracle (12,1,1) <-. rnorm.
  
  (* we just use the rlet to simplify terms for the manual proof *)
  rlet_abstract 13 h1 H(g ^ u,g ^ v,g ^ z2). rlet_abstract 15 h2 H(ea,ea',ec).
  rlet_abstract 15 la1 log(ea). rlet_abstract 15 la2 log(ea').
  (* try: rnorm. rindep.
     get: w*w*u*h1*la1 - w*v*h1*la1 - w*u*h1*la2 + v*h1*la2 - w*w*u*h2*la1 + w*u*h2*la2 + w*v*h2*la1 - v*h2*la2
     factored: (-1) * (h2 - h1) * (la2 - -w*la1) * (v - -w*u)
     we already have everything except (h2 - -h1)
  *)
  rcase_ev h2 = h1.
    last. rnorm. rindep.
  rnorm.
  
  (* if EV ==> not ((ga,ga',gc) = (g ^ u,g ^ v,g ^ z2)) /\ H(ga,ga',gc) = H(g ^ u,g ^ v,g ^ z2), we can apply TCR *)
  rcase_ev (ea,ea',ec) = (g ^ u,g ^ v,g ^ z2).
    rsplit_ev 5. rrewrite_ev 5 ->. rrewrite_ev 6 ->. rrewrite_ev 7 ->. rrewrite_ev 3 ->.
    rnorm. rfalse_ev.
  rremove_ev 1. rremove_ev 1. rremove_ev 1. rnorm_unknown u v z2. rswap 2 -1. rexcept 3. rswap 3 -1.
    rswap 9 -6. rlet_abstract 4 tu g^u. rlet_abstract 5 tv g^v. rlet_abstract 6 tz g^z2.
    assumption_computational tcr (ea,ea',ec).

  extract "extraction/cramer_shoup.ec".