adversary A1 : G -> (BS_k * BS_k).
adversary A2 : (G * BS_k) -> Bool.
random oracle H : G -> BS_k.
assumption ddh
  [ x <-$ Fq; y <-$ Fq;
    let gx = g ^ x; let gy = g ^ y; let gxy = g ^ (x * y); ]
  [ x <-$ Fq; y <-$ Fq; z <-$ Fq;
    let gx = g ^ x; let gy = g ^ y; let gxy = g ^ z; ]
    x y z.


prove
  [ sk <-$ Fq;
    let pk = g ^ sk;
    (m0,m1) <- A1(pk);
    b <-$ Bool;
    let mb = (b?m0:m1);
    y <-$ Fq;
    let he = H(pk ^ y);
    let c  = (g ^ y, he ++ mb);
    b' <- A2(c);
  ] : b = b'.  

print_goals : start.

rbad 7 x.

print_goals : after_bad.

rrandom 7 (v -> v ++ mb) (v -> v ++ mb) z1.
print_goals : after_random1.

rnorm.

print_goals : after_random2.

rswap 3 3. rindep. 

rnorm.
print_goals : bounding_bad.
rswap 4 -2.
print_goals : after_swap.

rlet_abstract 2 gsk (g^sk).
rlet_abstract 3 gy (g^y).
rlet_abstract 4 gsky (g^(sk*y)).
print_goals : after_rlet.

assumption -> ddh u.
rnorm.
rswap 3 4.
print_goals : after_ddh.

rctxt_ev (v -> log(v)).
rnorm.

print_goals : after_ev.
rindep.

print_goals : after_end.
