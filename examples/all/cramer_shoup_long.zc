adversary A_ddh : (G * G * G) -> Bool.

assumption ddh ([x,y])
  [ x <-$ Fq; y <-$ Fq;           b <- A_ddh(g ^ x,g ^ y,g ^ (x * y)); ]
  [ x <-$ Fq; y <-$ Fq; z <-$ Fq; b <- A_ddh(g ^ x,g ^ y,g ^ z);       ].

operator H : (G * G * G) -> Fq.

adversary A_tcr : (G * G * G) -> (G * G * G).

assumption tcr
  [ a <-$ Fq; b <-$ Fq; c <-$ Fq; (x1,x2,x3) <- A_tcr(g^a,g^b,g^c); ]
  : (H(x1,x2,x3) = H(g^a,g^b,g^c)) /\ not ((x1,x2,x3) = (g^a,g^b,g^c)).

adversary A1 : (G * G * G * G) -> (G * G).
adversary A2 : (G * G * G * G) -> Bool.
oracle Dec1 : (G * G * G * G) -> G.
oracle Dec2 : (G * G * G * G) -> G.

bound_adv
  [ w  <-$ Fq;
    x1 <-$ Fq;
    x2 <-$ Fq;
    y1 <-$ Fq;
    y2 <-$ Fq;
    z1 <-$ Fq;
    z2 <-$ Fq;
    (* secret key is x1,x2,y1,y2,z1,z2 *)
    let p1 = g^(x1+w*x2);
    let p2 = g^(y1+w*y2);
    let p3 = g^(z1+w*z2);
    let p4 = g^w;
    
    (m0,m1) <- A1(p1,p2,p3,p4) with
      Dec1(a,a',c,d) =
        [ c * (a^z1 * a' ^z2)^(-1)
        | d = a^(x1+H(a,a',c)*y1) * a'^(x2+H(a,a',c)*y2) ];

    b <-$ Bool;
    let mb = (b?m0:m1);
    (* randomness for encryption is u *)
    u <-$ Fq;
    let sa  = g^u;
    let sa' = p4^u;
    let sc  = mb * p3^u;
    let sd  = p1^u * p2^(u*H(sa,sa',sc));

    b' <- A2(sa,sa',sc,sd) with
      Dec2(a,a',c,d) =
        [ c * (a^z1 * a'^z2)^(-1)
        | not ((a,a',c,d) = (sa,sa',sc,sd)),
          d = a^(x1+H(a,a',c)*y1) * a'^(x2+H(a,a',c)*y2) ];

  ] : b = b'.
  
  (* decisional assumption *)
  let_unfold. norm_unknown u w. swap 10 -8.
  let_abstract 3 arg (g^w,g^u,g^(w*u)).
  let_abstract _ res _.
  assumption_decisional ddh -> (3-13) v.
  norm.
  
  (* rnd rule for x1, y1, z1 *)
  except 3 u*w.
  rnd! x1 _ (x1 -> x1 + w*x2).
  rnd! y1 _ (y1 -> y1 + w*y2).
  rnd! z1 _ (z1 -> z1 + w*z2).
  norm.
  
  (* add test to Dec1 *)
  add_test (10,1,1) (a^w = a') A3 ga ga' gc gd.
    bycrush.

  (* rnd to x2 and y2 *)
  simp. norm. swap 4 7.
  rnd x2 _ _. norm.
  rnd! z2 _ _. norm.
  
  (* add test to Dec2 *)
  add_test (12,1,2) (a^w = a') A4 ea ea' ec ed.
    last. bycrush.

  (* exclude hash collision *)
  simp. norm.
  case_ev H(ea,ea',ec) = H(g^u,g^v,g^z2).
    last. bycrush.
  simp. norm.
  case_ev (ea,ea',ec) = (g^u,g^v,g^z2).
    bycrush.
  swap 2 -1. swap 11 -9.
  except 4. swap 4 -2.
  remove_ev 1 2 3.
  let_abstract 4 arg (g^u,g^v,g^z2) 0.
  let_abstract 0 res1 ea.
  let_abstract 0 res2 ea'.
  let_abstract 0 res3 ec.
  assumption_computational tcr (4-16).
qed.
print_proof!.
extract "extraction/cramer_shoup_long.ec".