(* ----------------------------------------------------------------- *)
(* Define assumptions                                                *)
(* ----------------------------------------------------------------- *)

(* ----------------------------------------------------------------- *)
(* DDH assumption *)
adversary A_ddh : (G * G * G * G) -> Bool.

assumption_decisional ddh
  [ g1 <-$ G\g^0; g2 <-$ G\g^0; y <-$ Fq;
    b <- A_ddh(g1,g2,g1^y,g2^y); ]
  [ g1 <-$ G\g^0; g2 <-$ G\g^0; y <-$ Fq; z <-$ Fq;
    b <- A_ddh(g1,g2,g1^y,g2^z); ].

(* ----------------------------------------------------------------- *)
(* Hash funcion (secure wrt. TCR) *)

(* The first component is the index of the hash function, i.e.,
   "sample i and use H(i,-)" corresponds to "sample random H in HH". *)
operator H : (BS_i * G * G) -> Fq.

adversary A_tcr : (BS_i * G * G) ->  (G * G).

assumption_computational tcr
  [ i <-$ BS_i; a <-$ Fq; b <-$ Fq; (gu,gv) <- A_tcr(i,g^a,g^b); ]
  : (H(i,gu,gv) = H(i,g^a,g^b)) /\ ((gu,gv) <> (g^a,g^b)).

(* It seems like the following definition is actually required to
   make the original proof go through, i.e., the adversary knows the
   discrete logarithms of the chosen inputs. *)
adversary A_tcr_dlog : (BS_i * Fq * Fq) ->  (G * G).

assumption_computational tcr_dlog
  [ i <-$ BS_i; a <-$ Fq; b <-$ Fq; (gu,gv) <- A_tcr_dlog(i,a,b); ]
  : (H(i,gu,gv) = H(i,g^a,g^b)) /\ ((gu,gv) <> (g^a,g^b)).

(* ----------------------------------------------------------------- *)
(* Key derivation function *)

operator Kdf : G  -> (BS_km * BS_ks).

adversary A_kdf :  (BS_km * BS_ks) -> Bool.

assumption_decisional kdf
  [ x <-$ Fq; res <- A_kdf(Kdf(g^x)); ]
  [ km <-$ BS_km; ks <-$ BS_ks; res <- A_kdf(km,ks); ].

(* ----------------------------------------------------------------- *)
(* Symmetric encryption (secure wrt. CPA1) *)

operator Enc : (BS_ks * BS_msg) -> BS_enc.
operator Dec : (BS_ks * BS_enc) -> BS_msg.

adversary A1_cpa1 : () -> (BS_msg * BS_msg).
adversary A2_cpa1 : BS_enc -> Bool.

assumption_computational cpa1
  [ ks      <-$ BS_ks;
    b       <-$ Bool;
    (m0,m1) <-  A1_cpa1();
    b'      <-  A2_cpa1(Enc(ks,b?m0:m1));
  ] : b = b'.

(* ----------------------------------------------------------------- *)
(* MAC (secure wrt. CMA1) *)

operator Mac : (BS_km * BS_enc) -> BS_tag.

adversary A1_cma1 : () -> BS_enc.
adversary A2_cma1 : BS_tag -> (BS_enc * BS_tag).

assumption_computational cma1
  [ km    <-$ BS_km;
    ec    <-  A1_cma1();
    (e,t) <-  A2_cma1(Mac(km,ec));
  ] : (Mac(km,e) = t) /\ (e <> ec).

adversary A2_cma0 : () -> (BS_enc * BS_tag).

assumption_computational cma0
  [ km    <-$ BS_km;
    (e,t) <-  A2_cma0();
  ] : (Mac(km,e) = t).

(* ----------------------------------------------------------------- *)
(* Trivial equalities between distributions *)

adversary A_samp_exp : G -> Bool.

assumption_decisional samp_exp
  [ ga <-$ G;  res <- A_samp_exp(ga);  ]
  [ a  <-$ Fq; res <- A_samp_exp(g^a); ].

adversary A_samp_gen : G -> Bool.

assumption_decisional samp_gen
  [ ga <-$ G\g^0; res <- A_samp_gen(ga);  ]
  [ a  <-$ Fq\0;  res <- A_samp_gen(g^a); ].
  
(* ----------------------------------------------------------------- *)
(* Define IND-CCA security experiment                                *)
(* ----------------------------------------------------------------- *)

adversary A1 : (BS_i * G * G * G * G) -> (BS_msg * BS_msg).
adversary A2 : (G * G * BS_enc * BS_tag) -> Bool.

oracle Dec1 : (G * G * BS_enc * BS_tag) -> BS_msg.
oracle Dec2 : (G * G * BS_enc * BS_tag) -> BS_msg.

prove
  [ 
    (* Sample a hash function (its index) and two generators of G *)
    i <-$ BS_i;
    g1 <-$ G \ g^0;
    g2 <-$ G \ g^0;

    (* secret key is x1,x2,y1,y2,z1 *)
    x1 <-$ Fq;
    x2 <-$ Fq;
    y1 <-$ Fq;
    y2 <-$ Fq;
    let c = g1^x1*g2^x2;
    let d = g1^y1*g2^y2;
    
    (* give public key to adversary *)
    (m0,m1) <- A1(i,g1,g2,c,d) with
      Dec1(u1,u2,e,t) =
        [ Dec(ks,e)
        | let alpha = H(i,u1,u2),
          let v = u1^(x1 + y1*alpha)*u2^(x2 +y2*alpha),
          let k = Kdf(v),
          let km = k\0,
          let ks = k\1,
          Mac(km,e) = t ];
  
    b <-$ Bool;
    let mb = (b?m0:m1);

    (* ciphertext with randomness r *)
    r1 <-$ Fq;
    let cu1 = g1^r1;
    let cu2 = g2^r1;
    let ca = H(i,cu1,cu2);
    let cv = c^r1*d^(r1*ca);
    let ck = Kdf(cv);
    let ce = Enc(ck\1,mb);
    let ct = Mac(ck\0,ce);
    b' <- A2(cu1,cu2,ce,ct) with
      Dec2(u1,u2,e,t) =
        [ Dec(ks,e)
        | not ((u1,u2,e,t) = (cu1,cu2,ce,ct)),
          let alpha = H(i,u1,u2),
          let v = u1^(x1 + y1*alpha)*u2^(x2 +y2*alpha),
          let k = Kdf(v),
          let km = k\0,
          let ks = k\1,
          Mac(km,e) = t ];
  ] : b = b'.

(* apply DDH to g1,g2,r1 *)
rnorm. rnorm_unknown r1.
rswap 2 -1. rswap 3 - 1. rswap 10 - 7.
rlet_abstract 4 arg (g1,g2,g1^r1,g2^r1).
rlet_abstract 13 res (b = b').
rsubst 5 g1^r1 arg\2. rsubst 5 g2^r1 arg\3.
rsubst 5 g1 arg\0. rsubst 5 g2 arg\1.
assumption_decisional! ddh -> (4-13) r2.
rlet_unfold. rnorm_unknown.

(* sample exponent of g2 directly *)
rswap 2 -1. rlet_abstract 2 arg g2. rlet_abstract 14 res (b = b').
assumption_decisional! samp_gen -> (2-14) w. rnorm.

(* define g2 using the generator g1 instead of g2 *)
rswap 2 -1. rexcept 2. rrnd! 2 (w -> w*log(g1)) (w -> w/log(g1)).
rlet_unfold. rnorm_unknown.

rnorm.
rrnd 6 _ (x1 -> x1 + x2*w). rnorm.
rrnd 7 _ (y1 -> y1 + y2*w). rnorm.

rnorm_solve x2.
radd_test (10,1,1) (u1^w = u2) CC tu1 tu2 te tt.
  rsimp. rlet_unfold.
  rnorm_solve x2.
  rswap 6 4.
  rlet_abstract 10 d (log(tu2) - w*log(tu1)).
  rlet_abstract 11 e (x1*log(tu1) + y1*log(tu1)*H(i,tu1,tu2) + y2*log(tu2)*H(i,tu1,tu2) + -(y2*w*log(tu1)*H(i,tu1,tu2))).
  rrnd! 12 (x2 -> (x2 - e) / ((d=0)?1:d)) (x2 -> x2 * ((d=0)?1:d) + e).
  rnorm.
  rcase_ev (((log(tu2) + -(w*log(tu1))) = 0) = false).
    last. rnorm. rctxt_ev (c -> c + w*log(tu1)) 2. rnorm.
    rctxt_ev (c -> g^c) 3. rnorm. rrewrite_ev 3. rsimp. last.
  rrewrite_ev 3 ->. rnorm.
  rremove_ev 2.
  rswap 10 -9.
  rnorm_unknown.
  rlet_abstract 2 arg Kdf(g^x2).
  rlet_abstract _ res _.
  assumption_decisional! kdf -> (2-12) km ks.
  rnorm.
  rnorm_unknown.
  rlet_abstract 2 arg ().
  rlet_abstract 13 res1 te.
  rlet_abstract 14 res2 tt.
  rremove_ev 1.
  assumption_computational! cma0 (2-14).

radd_test (12,1,2) (u1^w = u2) CCC tu1 tu2 te tt.
  (* handle b = b' case first *)
  last.
  rsimp.
  rexcept 2 0.
  rexcept 4 r1.
  rnorm_unknown.
  rlet_abstract 11 cH H(i,g1 ^ r1,g1 ^ (r2*w)).
  rrnd 6 _ 
    (x2 ->
      log(g1)*
        (x1*r1 + x2*r2*w + y1*r1*cH + y2*r2*w*cH + -(x2*r1*w) + -(y2*r1*w*cH))).
  rnorm.
  rnorm_unknown.
  rswap 11 -10.
  rlet_abstract 2 arg Kdf(g^x2).
  rlet_abstract 14 res (b=b').
  assumption_decisional! kdf -> (2-14) km ks.
  rnorm.
  rswap 1 1. rswap 12 -10.
  rnorm_unknown.
  rlet_abstract 3 arg1 ().
  rlet_abstract 14 res1_1 m0.
  rlet_abstract 15 res1_2 m1.
  rlet_abstract 16 arg2 Enc(ks,b?res1_1:res1_2).
  rlet_abstract 18 res2 b'.
  assumption_computational! cpa1 (3-15,16-18).

rcase_ev (tu1,tu2) = (g ^ (r1*log(g1)),g ^ (log(g1)*r2*w)).
  rnorm. rsimp. rrewrite_ev 2 ->. rrewrite_ev 3 ->. rnorm.
  rnorm_solve x2.
  rexcept 2 0.
  rexcept 4 r1.
  rrnd 6 _ _. back. rnorm.
  rrewrite_ev 4 <-.
  rcase_ev (te = Enc(Kdf(g ^ x2)\1,b?m0:m1)).
    rrewrite_ev 6 ->. rnorm. rfalse_ev.
  rswap 11 -10.
  rnorm_unknown.
  rlet_abstract 2 arg Kdf(g^x2).
  rlet_abstract _ res _.
  assumption_decisional! kdf -> (2-14) km ks.
  rnorm.
  rnorm_unknown.
  rremove_ev 1. rremove_ev 1. rremove_ev 1. rremove_ev 2.
  rlet_abstract 2 arg1 ().
  rlet_abstract 14 res1 Enc(ks,b?m0:m1).
  rlet_abstract 15 arg2 Mac(km,res1).
  rlet_abstract 17 res1_1 te.
  rlet_abstract 18 res1_2 tt.
  assumption_computational! cma1 (2-14,15-18).
rsimp. rnorm.
rcase_ev (H(i,tu1,tu2) = H(i,g ^ (r1*log(g1)),g ^ (log(g1)*r2*w))).
  rremove_ev 1. rremove_ev  1. rremove_ev 2.
  rnorm_unknown r1 r2.
  rrnd 3 _ (r1 -> r1*log(g1)). rnorm.
  rexcept 2 0.
  rrnd 3 _ (r2 -> r2*log(g1)*w). rnorm.
  rnorm_unknown r1 r2.
  rswap 3 -2.
  rswap 10 -8.
  rswap 11 -8.
  rlet_abstract 4 arg (i,g^r1,g^r2).
  rsubst 5 i    arg\0.  
  rsubst 5 g^r1 arg\1.
  rsubst 5 g^r2 arg\2.
  rlet_abstract 14 res1 tu1.
  rlet_abstract 15 res2 tu2.
  assumption_computational! tcr (4-15).
rremove_ev 4.
rnorm_solve y2.
rexcept 2 0.
rexcept 4 r1.
rrnd 6 _ _. back. back. back. back. 
rnorm.
rnorm_solve y2.
rlet_abstract 13 d (H(i,tu1,tu2) + -H(i,g ^ (r1*log(g1)),g ^ (log(g1)*r2*w))).
rswap 6 7.
rrnd! 13 (y -> (y/(((d=0)?1:d)))) (y -> y * ((d=0)?1:d)). rlet_unfold 14.
rcase_ev ((d=0)=false).
  last. rremove_ev 4. rnorm. rctxt_ev (c -> c + H(i,g ^ (r1*log(g1)),g ^ (log(g1)*r2*w))) 4. rnorm. rrewrite_ev 3. rsimp.
  last. last.
rrewrite_ev 5.
rcase_ev ((false?1:d) = d).
  last. rremove_ev 1. rsimp.
rrewrite_ev 6.
rlet_unfold 12.
rremove_ev 6.
rnorm. rnorm_solve y2.
rrnd 12 _ (y2 -> y2*(r2 + -r1)*w*log(g1)). rnorm. rnorm_solve y2.
rlet_abstract 12 d (-log(tu2) + w*log(tu1)).
rrnd! 13 (y -> (y/(((d=0)?1:d)))) (y -> y * ((d=0)?1:d)). rlet_unfold 14.
rcase_ev ((d=0)=false).
  last. rremove_ev 5. rnorm. rctxt_ev (c -> c - -log(tu2)) 5. rnorm. rctxt_ev (c -> g^c) 5. rnorm.
  rrewrite_ev 1 <-. rsimp.
rrewrite_ev 6.
rcase_ev ((false?1:d) = d).
  last. rremove_ev 1. rsimp.
rrewrite_ev 7.
rlet_unfold 12.
rremove_ev 7.
rnorm. rnorm_solve y2.
rrnd 12 _ _. rnorm.
rswap 12 -11. rremove_ev 1 2 3 4 5.
rnorm_unknown.
rlet_abstract 2 arg Kdf(g^y2).
rlet_abstract _ res _.
assumption_decisional! kdf -> (2-14) km ks.
rlet_unfold. rnorm_unknown.
rlet_abstract 2 arg ().
rlet_abstract 15 res1 te.
rlet_abstract 16 res2 tt.
assumption_computational! cma0 (2-16).
qed.