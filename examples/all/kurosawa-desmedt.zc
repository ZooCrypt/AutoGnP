(* ----------------------------------------------------------------- *)
(* Define assumptions                                                *)
(* ----------------------------------------------------------------- *)

(* ----------------------------------------------------------------- *)
(* DDH assumption *)
adversary A_ddh : (G * G * G * G) -> Bool.

assumption ddh
  [ g1 <-$ G\g^0; g2 <-$ G\g^0; y <-$ Fq;
    b <- A_ddh(g1,g2,g1^y,g2^y); ]
  [ g1 <-$ G\g^0; g2 <-$ G\g^0; y <-$ Fq; z <-$ Fq;
    b <- A_ddh(g1,g2,g1^y,g2^z); ].

(* ----------------------------------------------------------------- *)
(* Hash funcion (secure wrt. TCR) *)

(* The first component is the index of the hash function, i.e.,
   "sample i and use H(i,-)" corresponds to "sample random H in HH". *)
operator H : (BS_i * G * G) -> Fq.

adversary A_tcr : (BS_i * G * G) ->  (G * G).

assumption tcr
  [ i <-$ BS_i; a <-$ Fq; b <-$ Fq; (gu,gv) <- A_tcr(i,g^a,g^b); ]
  : (H(i,gu,gv) = H(i,g^a,g^b)) /\ ((gu,gv) <> (g^a,g^b)).

(* It seems like the following definition is actually required to
   make the original proof go through, i.e., the adversary knows the
   discrete logarithms of the chosen inputs. *)
adversary A_tcr_dlog : (BS_i * Fq * Fq) ->  (G * G).

assumption tcr_dlog
  [ i <-$ BS_i; a <-$ Fq; b <-$ Fq; (gu,gv) <- A_tcr_dlog(i,a,b); ]
  : (H(i,gu,gv) = H(i,g^a,g^b)) /\ ((gu,gv) <> (g^a,g^b)).

(* ----------------------------------------------------------------- *)
(* Key derivation function *)

operator Kdf : G  -> (BS_km * BS_ks).

adversary A_kdf :  (BS_km * BS_ks) -> Bool.

assumption kdf
  [ x <-$ Fq; res <- A_kdf(Kdf(g^x)); ]
  [ km <-$ BS_km; ks <-$ BS_ks; res <- A_kdf(km,ks); ].

(* ----------------------------------------------------------------- *)
(* Symmetric encryption (secure wrt. CPA1) *)

operator Enc : (BS_ks * BS_msg) -> BS_enc.
operator Dec : (BS_ks * BS_enc) -> BS_msg.

adversary A1_cpa1 : () -> (BS_msg * BS_msg).
adversary A2_cpa1 : BS_enc -> Bool.

assumption cpa1
  [ ks      <-$ BS_ks;
    b       <-$ Bool;
    (m0,m1) <-  A1_cpa1();
    b'      <-  A2_cpa1(Enc(ks,b?m0:m1));
  ] : b = b'.

(* ----------------------------------------------------------------- *)
(* MAC (secure wrt. CMA1) *)

operator Mac : (BS_km * BS_enc) -> BS_tag.

adversary A1_cma1 : () -> BS_enc.
adversary A2_cma1 : BS_tag -> (BS_enc * BS_tag).

assumption cma1
  [ km    <-$ BS_km;
    ec    <-  A1_cma1();
    (e,t) <-  A2_cma1(Mac(km,ec));
  ] : (Mac(km,e) = t) /\ (e <> ec).

adversary A2_cma0 : () -> (BS_enc * BS_tag).

assumption cma0
  [ km    <-$ BS_km;
    (e,t) <-  A2_cma0();
  ] : (Mac(km,e) = t).

(* ----------------------------------------------------------------- *)
(* Trivial equalities between distributions *)

adversary A_samp_exp : G -> Bool.

assumption samp_exp
  [ ga <-$ G;  res <- A_samp_exp(ga);  ]
  [ a  <-$ Fq; res <- A_samp_exp(g^a); ].

adversary A_samp_gen : G -> Bool.

assumption samp_gen
  [ ga <-$ G\g^0; res <- A_samp_gen(ga);  ]
  [ a  <-$ Fq\0;  res <- A_samp_gen(g^a); ].
  
(* ----------------------------------------------------------------- *)
(* Define IND-CCA security experiment                                *)
(* ----------------------------------------------------------------- *)

adversary A1 : (BS_i * G * G * G * G) -> (BS_msg * BS_msg).
adversary A2 : (G * G * BS_enc * BS_tag) -> Bool.

oracle Dec1 : (G * G * BS_enc * BS_tag) -> BS_msg.
oracle Dec2 : (G * G * BS_enc * BS_tag) -> BS_msg.

prove
  [ 
    (* Sample a hash function (its index) and two generators of G *)
    i <-$ BS_i;
    g1 <-$ G \ g^0;
    g2 <-$ G \ g^0;

    (* secret key is x1,x2,y1,y2,z1 *)
    x1 <-$ Fq;
    x2 <-$ Fq;
    y1 <-$ Fq;
    y2 <-$ Fq;
    let c = g1^x1*g2^x2;
    let d = g1^y1*g2^y2;
    
    (* give public key to adversary *)
    (m0,m1) <- A1(i,g1,g2,c,d) with
      Dec1(u1,u2,e,t) =
        [ Dec(ks,e)
        | let alpha = H(i,u1,u2),
          let v = u1^(x1 + y1*alpha)*u2^(x2 +y2*alpha),
          let k = Kdf(v),
          let km = k\0,
          let ks = k\1,
          Mac(km,e) = t ];
  
    b <-$ Bool;
    let mb = (b?m0:m1);

    (* ciphertext with randomness r *)
    r1 <-$ Fq;
    let cu1 = g1^r1;
    let cu2 = g2^r1;
    let ca = H(i,cu1,cu2);
    let cv = c^r1*d^(r1*ca);
    let ck = Kdf(cv);
    let ce = Enc(ck\1,mb);
    let ct = Mac(ck\0,ce);
    b' <- A2(cu1,cu2,ce,ct) with
      Dec2(u1,u2,e,t) =
        [ Dec(ks,e)
        | not ((u1,u2,e,t) = (cu1,cu2,ce,ct)),
          let alpha = H(i,u1,u2),
          let v = u1^(x1 + y1*alpha)*u2^(x2 +y2*alpha),
          let k = Kdf(v),
          let km = k\0,
          let ks = k\1,
          Mac(km,e) = t ];
  ] : b = b'.

(* apply DDH to g1,g2,r1 *)
let_unfold. norm_unknown r1.
swap 2 -1. swap 3 - 1. swap 10 - 7.
let_abstract 4 arg (g1,g2,g1^r1,g2^r1). let_abstract _ res _.
assumption_decisional ddh -> (4-13) r2.
let_unfold. norm_unknown.

(* sample exponent of g2 directly *)
swap 2 -1. let_abstract 2 arg g2. let_abstract _ res _.
assumption_decisional samp_gen -> (2-14) w. norm.

(* define g2 using the generator g1 instead of g2 *)
swap 2 -1. except 2. rnd 2 _ (w -> w/log(g1)). norm.

rnd! 6 _ _ g1. norm.
rnd! 7 _ _ g1. norm.

norm_solve x2.
(* add test to first oracle *)
add_test (10,1,1) (u1^w = u2) CC tu1 tu2 te tt.
  simp. let_unfold. norm_solve x2.
  (* make Kdf input random *)
  swap 6 4.
  let_abstract [-1] d (log(tu2) - w*log(tu1)).
  let_abstract [-1] e (x1*log(tu1) + y1*log(tu1)*H(i,tu1,tu2) + y2*log(tu2)*H(i,tu1,tu2) + -(y2*w*log(tu1)*H(i,tu1,tu2))).
  rnd 12 (x2 -> (x2 - e) / ((d=0)?1:d)) (x2 -> x2 * ((d=0)?1:d) + e).
  norm.
  case_ev (((log(tu2) + -(w*log(tu1))) = 0) = false).
    last. (* implement more powerful false rule *)
    simp. norm. ctxt_ev (c -> g^(c + w*log(tu1))) 3. norm. simp. last.
  rewrite_ev 3 ->. norm. remove_ev 3.
  (* apply decisional Kdf assumption *)
  swap 10 -9. norm_unknown.
  let_abstract 2 arg Kdf(g^x2).
  let_abstract _ res _.
  assumption_decisional kdf -> (2-12) km ks.
  (* apply CMA0 assumption *)
  let_unfold. norm_unknown.
  let_abstract 2 arg ().
  let_abstract 0 res1 te.
  let_abstract 0 res2 tt.
  remove_ev 2.
  assumption_computational cma0 (2-14).

(* add test to second oracle *)
add_test (12,1,2) (u1^w = u2) CCC tu1 tu2 te tt.
  (* handle b = b' case first *)
  last. simp.
  (* make Kdf input random *)
  except 2 0.
  except 4 r1.
  norm_solve x2.
  rnd! 6 _ _. let_unfold. norm_unknown.
  swap 11 -10.
  let_abstract 2 arg Kdf(g^x2).
  let_abstract 14 res (b=b').
  assumption_decisional kdf -> (2-14) km ks.
  let_unfold.
  (* apply computational CPA1 assumption *)
  swap 2 -1. swap 12 -10.
  norm_unknown.
  let_abstract 3 arg1 ().
  let_abstract 14 res1_1 m0.
  let_abstract 15 res1_2 m1.
  let_abstract 16 arg2 Enc(ks,b?res1_1:res1_2).
  let_abstract 0 res2 b'.
  assumption_computational cpa1 (3-15,16-18).

(* equality on u1,u2, but not on ciphertext and Mac implies Mac forgery *)
case_ev (tu1,tu2) = (g ^ (r1*log(g1)),g ^ (log(g1)*r2*w)).
  (* make Kdf input random *)
  simp. norm.
  rewrite_ev 4 ->. rewrite_ev 5 ->. let_unfold.
  norm_solve x2.
  except 2 0. except 4 r1.
  rnd! 6 _ _. norm.
  case_ev (te = Enc(Kdf(g ^ x2)\1,b?m0:m1)).
    simp.
  (* apply Kdf security *)
  swap 11 -10. norm_unknown.
  let_abstract 2 arg Kdf(g^x2).
  let_abstract _ res _.
  assumption_decisional kdf -> (2-14) km ks.
  (* reduce to CMA1 *)
  let_unfold. norm_unknown.
  remove_ev 1 3 4 5.
  let_abstract 2 arg1 ().
  let_abstract 14 res1 Enc(ks,b?m0:m1).
  let_abstract 15 arg2 Mac(km,res1).
  let_abstract 0 res1_1 te.
  let_abstract 0 res1_2 tt.
  assumption_computational cma1 (2-14,15-18).

simp. norm.
(* Reduce hash collision case to TCR *)
case_ev (H(i,tu1,tu2) = H(i,g1^r1,g1^(r2*w))).
  (* apply TCR *)
  norm. remove_ev 1 2 3.
  rnd! 3 _ _. norm.
  except 2 0.
  rnd! 3 _ _. norm.
  norm_unknown r1 r2.
  swap 3 -2. swap 10 -8. swap 11 -8.
  let_abstract 4 arg (i,g^r1,g^r2).
  let_abstract 0 res1 tu1.
  let_abstract 0 res2 tu2.
  assumption_computational tcr (4-15).

(* finish proof exploiting that hashes are not equal *)
norm.
(* check in which contexts x2 and y2 occur *)
except w 0. except r2 r1.
norm. field_exprs x2 y2.
norm_solve x2. field_exprs x2.
rnd! x2 _ _. norm. norm_solve y2.
(* simplify expression, divide coefficient of y2 by values that are
   known to be nonzero *)
rnd! y2 _ (y2 -> y2*log(g1)*w*(r1 - r2)). norm. norm_solve y2. field_exprs y2.
let_abstract! 10 h1 H(i,g1^r1,g1^(r2*w)).
let_abstract! 0  h2 H(i,tu1,tu2). norm_solve y2.
let_abstract 0 d -((-log(tu2) + w*log(tu1))*(-h1 + h2)).
rnd! y2 _ (y2 -> y2*((d=0)?1:d)).
let_unfold [-1].
(* AC-match (y2 * ?d) + ?e *)
(* show that te <> Enc(k'\1,b?m0:m1) for CMA1 *)
case_ev (te = Enc(k'\1,b?m0:m1)).
  norm_unknown.
  norm. rsimp.
norm_unknown.
remove_ev 4.
norm_solve y2.
except 2 0.
except 4 r1.
rnd! 6 _ _. back. back. back. back. 
norm.
norm_solve y2.
let_abstract 13 d (H(i,tu1,tu2) + -H(i,g ^ (r1*log(g1)),g ^ (log(g1)*r2*w))).
swap 6 7.
rnd! 13 (y -> (y/(((d=0)?1:d)))) (y -> y * ((d=0)?1:d)). rlet_unfold 14.
case_ev ((d=0)=false).
  last. remove_ev 1 2. norm. ctxt_ev (c -> c + H(i,g ^ (r1*log(g1)),g ^ (log(g1)*r2*w))) 3. norm. rewrite_ev 3. simp.
  last. last.
rewrite_ev 5.
case_ev ((false?1:d) = d).
  last. remove_ev 1. rsimp.
rewrite_ev 6.
let_unfold 12.
remove_ev 6.
norm. norm_solve y2.
rnd 12 _ (y2 -> y2*(r2 + -r1)*w*log(g1)). norm. norm_solve y2.
let_abstract 12 d (-log(tu2) + w*log(tu1)).
rnd! 13 (y -> (y/(((d=0)?1:d)))) (y -> y * ((d=0)?1:d)). let_unfold 14.
case_ev ((d=0)=false).
  last. remove_ev 5. norm. ctxt_ev (c -> c - -log(tu2)) 5. norm. ctxt_ev (c -> g^c) 5. norm.
  rewrite_ev 1 <-. simp.
rewrite_ev 6.
case_ev ((false?1:d) = d).
  last. remove_ev 1. simp.
rewrite_ev 7.
let_unfold 12.
remove_ev 7.
(* apply decisional KDF assumption *)
norm. norm_solve y2.
rnd 12 _ _. norm.
swap 12 -11. remove_ev 1 2 3 4 5.
norm_unknown.
let_abstract 2 arg Kdf(g^y2).
let_abstract _ res _.
assumption_decisional! kdf -> (2-14) km ks.
(* reduce to CMA1 *)
let_unfold. norm_unknown.
let_abstract 2 arg ().
let_abstract 0 res1 te.
let_abstract 0 res2 tt.
assumption_computational! cma0 (2-16).
qed.