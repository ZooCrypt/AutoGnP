(* 
   IND-CPA Security of the BR93 scheme in the Random
   Oracle Model (ROM) under the assumption of a 
   computationally secure trapdoor permutation.  
*)

(* message length km, random length kr *)
random oracle H1 : (BS_km * BS_kr) -> BS_kh.

random oracle H2 : BS_kh -> (BS_km * BS_kr).

         (* Trapdoor permutation *)
permutation f : (BS_kh * (BS_km * BS_kr)).

        (* Computational assumption *)
adversary A_comp :
  (PKey_f *  (BS_kh * (BS_km * BS_kr))) ->  (BS_kh * (BS_km * BS_kr)).
assumption OW_comp_assm succ
  [ kp <-$ KeyPair_f; r <-$  (BS_kh * (BS_km * BS_kr)); 
    r_A <- A_comp(get_pk(kp),f(get_pk(kp),r)); ] 
    : r_A = r.
adversary A_comp1 : 
  (PKey_f *  (BS_kh * (BS_km * BS_kr))) -> BS_kh.
assumption OW_comp_assm1 succ
  [ kp <-$ KeyPair_f; r <-$  (BS_kh * (BS_km * BS_kr)); 
    r_A_0 <- A_comp1(get_pk(kp),f(get_pk(kp),r)); ] 
    : r_A_0 = (r#0).

             (* IND-CPA Game *)
adversary A_find  : PKey_f -> (BS_km * BS_km).
adversary A_guess : (BS_kh * (BS_km * BS_kr)) -> Bool.

oracle Dec : (BS_kh * (BS_km * BS_kr)) -> BS_km.

bound_adv
  [ b <-$ Bool;
    kp <-$ KeyPair_f;
    r <-$ BS_kr;
    let pk = get_pk(kp);
    let sk = get_sk(kp);
    (m0,m1) <- A_find(pk);
    let mb = b?m1:m0;
    let cs = H1(mb,r);
    let ch2 = H2(cs);
    let mbr = (mb,r);
    let ct = ch2 ++ mbr;
    let cb = f(pk,(cs,ct));
    b'<- A_guess(cb) with
      Dec(c) = {
        c <> cb;
        let st = f_inv(sk,c);
        let s = st#0;
        let t = st#1;
        let t1 = t#0;
        let t2 = t#1;
        let h2s = H2(s);
        let x = (((h2s#0) ++ t1),((h2s#1) ++ t2));
        s = H1(x);
        return x#0;
      };
    ] : b = b'.
    
    norm.
    abstract 5 mb (b?m1:m0).
    abstract 6 cs H1(mb,r).
    abstract 7 ch2 H2(cs).
    abstract 8 ct (ch2 ++ (mb,r)).
    abstract 9 pk get_pk(kp).
    abstract 10 sk get_sk(kp).
    guard (11,1,3) ((f_inv(sk,c)#0) <> cs).
    norm_nounfold.
    abstract (11,1,1) st f_inv(sk,c).
    abstract (11,1,2) s st#0.
    abstract (11,1,3) t st#1.
    abstract (11,1,4) ct' (t ++ H2(s)).
    norm_nounfold.
    unfold pk.
    help injective_ctxt_ev.
    injective_ctxt_ev 2 (y -> f_inv(get_sk(kp),y)) (x -> f(get_pk(kp),x)).
    norm_nounfold.
    rewrite_ev 1 <-.
    unfold sk.
    injective_ctxt_ev 2 (x -> x#1) (y -> (f_inv(get_sk(kp),c)#0,y)).
    norm_nounfold.
    injective_ctxt_ev 2 (x -> x ++ ch2) (y -> y ++ ch2).
    unfold ct.
    norm.
    
    
    norm_nounfold.
    abstract 8 ct (ch2 ++
    norm_nounfold.
    bycrush.
    
      case_ev (((f_inv(sk,c))#1) <> ct).
        admit.
        
        norm_nounfold.
        rewrite_ev 5 <-.
        norm_nounfold. (*It fails here *)
    
    
     (* norm_nounfold.
      ctxt_ev 4 (cc -> f(pk,cc)).
      norm.
      rewrite_ev 4 .
      norm.
      false_ev.*)
    
    rewrite_ev 1 <-.
    norm_nounfold.
    case_ev 
    subst 11 ( (f_inv(sk,c)#0,ct) -> f_inv(sk,c )
    ctxt_ev 2 ( ss -> f_inv(sk,ss) ).
    rewrite_ev 2.
    norm.
    find (pk0 f_cs_ct -> (c = f_cs_ct)) 
         (pk, cb) 
         A_finder c.
    
    norm.
    abstract 5 mb (b?m1:m0).
    abstract 6 cs H1(mb,r).
    (* s <> cs *)

    add_test (7,1,1) ((f_inv(get_sk(kp),c)#0) <> cs) AA gc.
    