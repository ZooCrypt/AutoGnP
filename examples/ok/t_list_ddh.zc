adversary A_ddh : (G * G * G) -> Bool.

assumption ddh ([x,y])
  [ x <-$ Fq; y <-$ Fq;           b <- A_ddh(g^x,g^y,g^(x*y)); ]
  [ x <-$ Fq; y <-$ Fq; z <-$ Fq; b <- A_ddh(g^x,g^y,g^z);     ].

adversary A_trivial : (Bool * Fq) -> Bool.

assumption trivial
  [ b <-$ Bool; u <-$ Fq; v <-$ Fq; res <- A_trivial(b,b?u:v); ]
  [ b <-$ Bool; u <-$ Fq;           res <- A_trivial(b,u); ].

oracle Samp : () -> (G * G *G).
adversary A : G -> Bool.

bound_adv
  [ b <-$ Bool;
    u <-$ G;
    b' <- A(u) with
      Samp() =
        [ (g^x,g^y,g^(b?x*y:z)) | x <-$ Fq, y <-$ Fq, z <-$ Fq ];
  ] : b = b'.
  
  hybrid (3,1) [ (g^x,g^y,g^z) | x <-$ Fq, y <-$ Fq, z <-$ Fq ] B.
    last. indep!.
  (* move sampling from "once-oracle" to main *)
  swap_main (4,1,1) mx.
  swap_main (5,1,1) my.
  swap_main (6,1,1) mz.
  (* apply DDH assumption *)
  swap 4 -3.
  swap 5 -3.
  swap 6 -3.
  subst 5 (g^(b?(mx*my):mz)) (b?g^(mx*my):g^mz).
  let_abstract 3 arg (g^mx,g^my,g^(mx*my)).
  let_abstract _ res _.
  assumption_decisional ddh -> (3-10) zz.
  (* apply trivial assumption *)
  norm.
  swap 4 -3.
  swap 4 -3.
  swap 5 -4.
  let_abstract 4 arg (b,b?zz:mz).
  let_abstract _ res _.
  assumption_decisional trivial -> (4-11).
  (* make the two games equal *)
  norm.
  dist_sym.
  swap_main (4,1,1) mx.
  swap_main (5,1,1) my.
  swap_main (6,1,1) zz.
  swap 6 -4.
  swap 5 -2.
  swap 6 -2.
  norm.
  dist_eq.
qed.