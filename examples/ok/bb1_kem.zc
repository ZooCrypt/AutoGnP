bilinear map e : G * G -> G_t.

adversary A1 : () -> Fq.
adversary A2 : (G * G * G * G_t * G * G) -> Bool.

oracle Kg1 : Fq -> (G * G).

(* DBDH assumption *)
adversary A_dbdh : (G * G * G * G_t) -> Bool.

assumption dbdh
  [ c1 <-$ Fq; c2 <-$ Fq; c3 <-$ Fq;
    b <- A_dbdh(g^c1, g^c2, g^c3, e(g,g)^(c1*c2*c3)); ]
  [ c1 <-$ Fq; c2 <-$ Fq; c3 <-$ Fq; t <-$ Fq;
    b <- A_dbdh(g^c1, g^c2,g^c3, e(g,g)^t); ].

bound_adv
  [ i' <- A1();
    (* master secret key *)
    c, d, h <-$ Fq;
    let pk1 = g^c;
    let pk2 = g^d;
    let pk3 = g^h;
    (* encapsulate challenge session key *)
    b <-$ Bool;
    e' <-$ Fq;
    K1 <-$ G_t;
    let Kb = b?e(pk1,pk2)^e':K1;
    let C1 = g^e';
    let C2 = (pk2^i'*pk3)^e';

    (* FIXME: required for proof, implement insert rule *)
    xxx <-$ Fq;
    b' <- A2(pk1,pk2,pk3,Kb,C1,C2)  with
      Kg1(i) = {
        i<>i';
        r <-$ Fq;
        return (g^(c*d + r*(d*i + h)), g^r)
      };
  ] : b = b'.
  swap c (1); swap d (2); swap e' (3).
  rnd h _ (h -> h + d*i'); //.
  rnd_oracle (9,1,2) _ (r -> r * (i - i') + c); //.
  assumption_decisional! dbdh -> tt; //.
  rnd K1 (t : Fq -> g_t^t) _; //.
  rnd! tt (tt -> tt + xxx) _; //.
  rnd! t  (t -> t + xxx)   _; //.
  (* FIXME: decide what to do with normal form of ifte: c?a:b -> check if norm(a) = norm(b), otherwise, push outwards?
            or try to push more inwards? *)
  trans* [ subst t (b?(xxx + tt):(xxx + t) -> (b?tt:t) + xxx) ]. admit.
  rnd! xxx _ _.
  bycrush.
qed.
print_proof.
extract "extraction/bb1.ec".