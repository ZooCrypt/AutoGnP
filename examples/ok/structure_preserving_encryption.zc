bilinear map e : G * G -> G_t.

adversary A1 : G^17 -> (G * G * G).
adversary A2 : (G * G * G * G * G_t) -> Bool.

oracle Dec1 : (G * G * G * G * G_t * G) -> G.
oracle Dec2 :  (G * G * G * G * G_t * G) -> G.

adversary A_dlin : G^6 -> Bool.

assumption dlin
  [ g1 <-$ G; g2 <-$ G; g3 <-$ G; r <-$ Fq; s <-$ Fq;
    b <- A_dlin(g1,g2,g3,g1^r,g2^s, g3^(r+s)); ]
  [ g1 <-$ G; g2 <-$ G; g3 <-$ G; r <-$ Fq; s <-$ Fq; t <-$ Fq;
    b <- A_dlin(g1,g2,g3,g1^r,g2^s, g3^t); ].

bound_adv
[ (* setup *)
  g1, g2, g3 <-$ G;

  a1, a2, a3 <-$ Fq;

  b01, b02, b03 <-$ Fq;
  b11, b12, b13 <-$ Fq;
  b21, b22, b23 <-$ Fq;
  b31, b32, b33 <-$ Fq;
  b41, b42, b43 <-$ Fq;
  b51, b52, b53 <-$ Fq;

  let h1 = g1^a1*g3^a3;
  let h2 = g2^a2*g3^a3;

  let f01 = g1^b01*g3^b03; let f02 = g2^b02*g3^b03;
  let f11 = g1^b11*g3^b13; let f12 = g2^b12*g3^b13;
  let f21 = g1^b21*g3^b23; let f22 = g2^b22*g3^b23;
  let f31 = g1^b31*g3^b33; let f32 = g2^b32*g3^b33;
  let f41 = g1^b41*g3^b43; let f42 = g2^b42*g3^b43;
  let f51 = g1^b51*g3^b53; let f52 = g2^b52*g3^b53;

  (m0,m1,sL) <- A1(g1,g2,g3,h1,h2,f01,f02,f11,f12,f21,f22,f31,f32,f41,f42,f51,f52) with
    Dec1(u1,u2,u3,c,v,L) = {
      let v' = e(u1^b01*u2^b02*u3^b03,g) *
               e(u1^b11*u2^b12*u3^b13,u1) *
               e(u1^b21*u2^b22*u3^b23,u2) *
               e(u1^b31*u2^b32*u3^b33,u3) *
               e(u1^b41*u2^b42*u3^b43,c) * e(u1^b51*u2^b52*u3^b53,L);
      v = v';
      return c / (u1^a1*u2^a2*u3^a3)
    };

  (* encryption of m with label L *)
  bg <-$ Bool;
  let m = bg?m0:m1;
  r <-$ Fq;
  s <-$ Fq;
  let su1 = g1^r;
  let su2 = g2^s;
  let su3 = g3^(r + s);
  let sc = m*h1^r*h2^s;
  let sv = e(f01^r*f02^s,g) *
           e(f11^r*f12^s,su1) *
           e(f21^r*f22^s,su2) *
           e(f31^r*f32^s,su3) *
           e(f41^r*f42^s,sc) * e(f51^r*f52^s,sL);
  bg' <- A2(su1,su2,su3,sc,sv)  with
    Dec2(u1,u2,u3,c,v,L) = {
      (u1,u2,u3,c,v,L) <> (su1,su2,su3,sc,sv,sL);
      let v' = e(u1^b01*u2^b02*u3^b03,g) *
               e(u1^b11*u2^b12*u3^b13,u1) *
               e(u1^b21*u2^b22*u3^b23,u2) *
               e(u1^b31*u2^b32*u3^b33,u3) *
               e(u1^b41*u2^b42*u3^b43,c) * e(u1^b51*u2^b52*u3^b53,L);
      v = v';
      return c / (u1^a1*u2^a2*u3^a3)
    };

] : (bg = bg').

norm.

(* Apply DLIN for g1, g2, g3, r, s *)
swap r (4). swap s (5).
assumption_decisional! dlin -> t; ///=.

(* sample exponents for g1, g2, and g3 *)
rnd_exp (g1 e1) (g2 e2) (g3 e3).
except e1 [0]. except e2 [0]. except e3 [0]. except t [r + s]. //; //=.

(* make view of adversary A1 independent of b*3 and a3 *)
rnd! b01 _ _; //. rnd! b02 _ _; //.
rnd! b11 _ _; //. rnd! b12 _ _; //.
rnd! b21 _ _; //. rnd! b22 _ _; //.
rnd! b31 _ _; //. rnd! b32 _ _; //.
rnd! b41 _ _; //. rnd! b42 _ _; //.
rnd! b51 _ _; //. rnd! b52 _ _; //.
rnd! a1 _ _;  //. rnd! a2 _ _;  //.

guard (28,1,2) (log(u3) = (e3*((log(u1) / e1) + (log(u2) / e2)))).
  (* swap and simplify in both branches *)
  swap (28,1,2) -1; rewrite_oracle (28,1,1) ->; //. last.
  swap (28,1,2) -1; rewrite_oracle (28,1,1) ->; //. last.
  guess A3 gu1 gu2 gu3 gc gv gL.
  bycrush.
guard (30,1,3) (log(u3) = (e3*((log(u1) / e1) + (log(u2) / e2)))).
  (* swap and simplify in both branches *)
  swap (30,1,3) -2; rewrite_oracle (30,1,1) ->; //. last.
  swap (30,1,3) -2; rewrite_oracle (30,1,1) ->; //.
  bycrush.
guess A3 gu1 gu2 gu3 gc gv gL.
swap (30,1,1) 2. simp; //.
(* make view of adversary independent of b{1,2,3,4,5}3 *)
rnd! b03 _ _. simp; //.
split_ineq 2.
  bysimp.
  indep!.
  indep!.
  indep!.
  indep!.
indep!.
qed.
extract "extraction/structure_preserving_encryption.ec".