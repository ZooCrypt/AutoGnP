bilinear map e : G * G -> G_t.

(* DBDH assumption *)
adversary A_dbdh : (G * G * G * G_t) -> Bool.

assumption dbdh
  [ c1 <-$ Fq; c2 <-$ Fq; c3 <-$ Fq;
    b <- A_dbdh(g^c1, g^c2, g^c3, e(g,g)^(c1*c2*c3)); ]
  [ c1 <-$ Fq; c2 <-$ Fq; c3 <-$ Fq; t <-$ Fq;
    b <- A_dbdh(g^c1, g^c2,g^c3, e(g,g)^t); ].

(* DLIN assumption *)
adversary A_dlin : (G * G * G * G * G) -> Bool.

assumption dlin
  [ b1 <-$ Fq; b2 <-$ Fq; c1 <-$ Fq; c2 <-$ Fq;
    b <- A_dlin(g^b1, g^b2, g^c1, g^(b1*c2), g^(b2*(c1+c2))); ]
  [ b1 <-$ Fq; b2 <-$ Fq; c1 <-$ Fq; c2 <-$ Fq; t <-$ Fq;
    b <- A_dlin(g^b1, g^b2, g^c1, g^(b1*c2), g^t); ].
    
adversary A_dkill : () -> Bool.

assumption [inf] dkill
  [ k <-$ Fq; b <- A_dkill(); ]
  [ b <- A_dkill(); ].
  
adversary A1 : (G*G*G*G*G*G*G*G*G*G*G*G*G_t) -> (Fq * G_t * G_t).
adversary A2 : (Fq*G_t*G*G*G*G*G*G*G*G*G) -> Bool.
oracle KeyGen1 : Fq -> (Fq*G*G*G*G*G*G*G*G).
oracle KeyGen2 : Fq -> (Fq*G*G*G*G*G*G*G*G).

bound_adv
[ (* setup *)
  V     <-$ G;
  V1    <-$ G;
  V2    <-$ G;
  W     <-$ G;
  U     <-$ G;
  H     <-$ G;
  a1    <-$ Fq;
  a2    <-$ Fq;
  b     <-$ Fq;
  alpha <-$ Fq;
  
  let tau1 = V*V1^a1;
  let tau2 = V*V2^a2;
  let P0   = g^b;
  let P1   = g^a1;
  let P2   = g^a2;
  let P3   = g^(b*a1);
  let P4   = g^(b*a2);
  let P5   = e(g,g)^(alpha*a1*b);
  (ci,m0,m1) <- A1(P0,P1,P2,P3,P4,tau1,tau2,tau1^b,tau2^b,W,U,H,P5)
    with
    KeyGen1(i) =
      [ (tagk,D1,D2,D3,D4,D5,D6,D7,k)
      | r1   <-$ Fq,
        r2   <-$ Fq,
        z1   <-$ Fq,
        z2   <-$ Fq,
        tagk <-$ Fq,
        let r  = r1 + r2,
        let D1 = g^(alpha*a1)*V^r,
        let D2 = g^(-alpha)*V1^r*g^z1,
        let D3 = (g^b)^-z1,
        let D4 = V2^r*g^z2,
        let D5 = (g^b)^-z2,
        let D6 = g^(r2*b),
        let D7 = g^r1,
        let k  = (U^i*W^tagk*H)^r1 ];
  
  beta <-$ Bool;  
  let m = beta?m0:m1;
  (* encryption of Enc(PK,i,m) *)
  s1   <-$ Fq;
  s2   <-$ Fq;
  t    <-$ Fq;
  tagc <-$ Fq;
  let C0 = m*P5^s2;
  let C1 = P0^(s1+s2);
  let C2 = P3^s1;
  let C3 = P1^s1;
  let C4 = P4^s2;
  let C5 = P2^s2;
  let C6 = tau1^s1*tau2^s2;
  let C7 = (tau1^b)^s1*(tau2^b)^s2*W^-t;
  let E1 = (U^ci*W^tagc*H)^t;
  let E2 = g^t;
  
  beta' <- A2(tagc,C0,C1,C2,C3,C4,C5,C6,C7,E1,E2)
    with
    KeyGen2(i) =
      [ (tagk,D1,D2,D3,D4,D5,D6,D7,k)
      | i <> ci,
        r1   <-$ Fq,
        r2   <-$ Fq,
        z1   <-$ Fq,
        z2   <-$ Fq,
        tagk <-$ Fq,
        let r  = r1 + r2,
        let D1 = g^(alpha*a1)*V^r,
        let D2 = g^(-alpha)*V1^r*g^z1,
        let D3 = (g^b)^-z1,
        let D4 = V2^r*g^z2,
        let D5 = (g^b)^-z2,
        let D6 = g^(r2*b),
        let D7 = g^r1,
        let k  = (U^i*W^tagk*H)^r1 ];
] : (beta = beta') /\ not (ci in Log (KeyGen1)).

(* ================================================ *)
(* make ciphertext semi-functional by applying DLIN *)

(* This is the game with semi-functional challenge ciphertext as given in the paper *)
trans*
  [ insert beta'
    [ (* modifications to make ciphertext semi-functional *)
      x <-$ Fq;
      let C4' = g^(b*a2*x);
      let C5' = g^(a2*x);
      let C6' = V2^(a2*x);
      let C7' = V2^(b*a2*x); ]
  , subst E2 (C4) (C4*C4')
  , subst E2 (C5) (C5*C5')
  , subst E2 (C6) (C6*C6')
  , subst E2 (C7) (C7*C7')
  ].
  _: norm.
  (* sample exponents instead of group elements to maximize deducibility for reduction *)
  _: rnd V  (v :  Fq -> g ^ v) _.  _: rnd V1 (v1 : Fq -> g ^ v1) _.
  _: rnd V2 (v2 : Fq -> g ^ v2) _. _: rnd W  (w :  Fq -> g^w) _.
  _: rnd U  (u :  Fq -> g ^ u) _.  _: rnd H  (h :  Fq -> g^h) _.
  _: //; //=.
  
  (* match p variables from assumption *)
  _: rename a1 b1. _: rename a2 b2. _: swap b1 (1). _: swap b2 (2).
  (* introduce remaining variables c1 and c2 from assumption. *)
  _: abstract 1 arg (). _: abstract _ res _.  _: assumption_decisional dkill <- [arg] c2. _: //; //=.
  _: abstract 1 arg (). _: abstract _ res _.  _: assumption_decisional dkill <- [arg] c1. _: //; //=.
  swap [c1 c2] b2.

  (* we could use DLIN now, but it would be useless since the expression
     b2*(c1+c2)) does not occur anywhere.
     So we perform the right opt. samplings to "mix in" c1 and c2. *)
  rnd s2 (s2 -> s2 + c1 + c2) _. rnd s1 (s1 -> s1 - c2)  _. _: //; //=.
  abstract* 5 arg (g^b1, g^b2, g^c1, g^(b1*c2), g^(b2*(c1+c2))).
  abstract _ res _.
  assumption_decisional dlin -> [arg] x. _: //; //=.
  swap x tagc.
  (* check differences, substitute some variable by polynomial to obtain additional terms existing on other side *)
  dist_sym.
  rnd  s2 (s2 -> s2 + c1 + c2) _.
  rnd! s1 (s1 -> s1 - c2) _.
  rnd! x _ (x -> x + c1 + c2).
  except b2 [0]. rnd x _ (x -> x*b2). _: //; //=.
  swap s1 s2. swap [c1 c2] b2. except b2 [].
  dist_eq.

(* ================================================== *)
(* make first oracle semi-functional by applying DLIN *)

hybrid (19,1)
  [ (tagk,D1,D2,D3,D4,D5,D6,D7,k) |
    r1 <-$ Fq,
    r2 <-$ Fq,
    z1 <-$ Fq,
    z2 <-$ Fq,
    tagk <-$ Fq,
    gamma <-$ Fq,
    let r = r2 + r1,
    let D1' = g^(a1*alpha) * V^r,
    let D2' = g^-alpha * V1^r * g^z1,
    let D3 = (g^b)^-z1,
    let D4' = V2^r * g^z2,
    let D5 = (g^b)^-z2,
    let D6 = g^(b*r2),
    let D7 = g^r1,
    let k = (H * U^i * W^tagk)^r1,
    let D1 = D1' * g^(-a1*a2*gamma),
    let D2 = D2' * g^(a2*gamma),
    let D4 = D4' * g^(a1*gamma) ].

  (* -------------------------------------------------- *)
  (* sample exponents instead of group elements to maximize deducibility for reduction *)
  _: rnd V  (v :  Fq -> g ^ v) _.  _: rnd V1 (v1 : Fq -> g ^ v1) _.
  _: rnd V2 (v2 : Fq -> g ^ v2) _. _: rnd W  (w :  Fq -> g^w) _.
  _: rnd U  (u :  Fq -> g ^ u) _.  _: rnd H  (h :  Fq -> g^h) _.
  _: //; //=.

  (* -------------------------------------------------- *)
  (* side-step incomplete handling of Log(KeyGen1) *)
  trans* [ subst 1 (not (ci in Log(KeyGen1))) (not (ci in Log(KeyGen1)) /\ (KeyGen1`i<>ci)) ]. admit.
  dist_sym. trans* [ subst 1 (not (ci in Log(KeyGen1))) (not (ci in Log(KeyGen1)) /\ (KeyGen1`i<>ci)) ]. admit.  _: // ; //=. dist_sym.

  (* -------------------------------------------------- *)
  (* introduce pairwise independent function A*i + B for tagc and tagk in =-oracle. *)
  assert beta (KeyGen1`i<>ci). bycrush.
  dist_sym. assert beta (KeyGen1`i<>ci). bycrush. dist_sym.
  _: rename tagc A.
  _: rnd A (A -> A*(ci - KeyGen1`i) + KeyGen1`tagk) _. _: //; //=.
  _: swap A (1).
  _: rnd_oracle (12,1,5,=) (tagk -> tagk + A*i) _. _: //; //=.
  _: swap_main (12,1,5) B. _: swap B (2).
  
  (* b1,b2 and c1,c2 will be used in reduction *)
  _: rename b b1.
  (* v = -b2*a1*a2 *)
  _: rename v b2. _: except a1 [0]. _: except a2 [0]. _: rnd! b2 (b2 -> -b2*a1*a2) _; // ; //=.
  _: rnd! v1 (v1 -> v1 + b2*a2) _; //; //=.
  _: rnd! v2 (v2 -> v2 + b2*a1) _; //; //=.
  _: rnd! w (w -> w + b1) _; //; //=.
  _: rnd! u (u -> u - b1*A) _; //; //=.
  _: rnd! h (h -> h - b1*B) _; //; //=.
  
  (* introduce remaining variables c1 and c2 from assumption. *)
  _: abstract 1 arg (). _: abstract _ res _.  _: assumption_decisional dkill <- [arg] c2. _: //; //=.
  _: abstract 1 arg (). _: abstract _ res _.  _: assumption_decisional dkill <- [arg] c1. _: //; //=.
  _: swap b1 (1). _: swap b2 (2).

  _: rnd_oracle (19,1,1,=) (r1 -> r1 + c1) _. _: //; //=.
  _: rnd_oracle (19,1,2,=) (r2 -> r2 + c2) _. _: //; //=.
  _: rnd_oracle (19,1,3,=) (z1 -> z1 - v1*c2) _. _: //; //=.
  _: rnd_oracle (19,1,4,=) (z2 -> z2 - v2*c2) _. _: //; //=.
  
  _: rnd! t (t -> t + a1*a2*x*b2) _. _: //; //=.

  abstract* 5 arg (g^b1, g^b2, g^c1, g^(b1*c2), g^(b2*(c1+c2))).
  abstract _ res _.
  assumption_decisional dlin -> [arg] tt. _: //; //=.
  swap tt (18).
  swap_main tt (19,1,1) gamma.
  swap (18,1,1,=) 4.
  rnd_oracle (18,1,5,=) (gamma -> gamma + b2*c1 + b2*c2) _. //; //=.
  dist_eq.

hybrid (41,1)
  [ (tagk,D1,D2,D3,D4,D5,D6,D7,k) |
    i <> ci,
    r1 <-$ Fq,
    r2 <-$ Fq,
    z1 <-$ Fq,
    z2 <-$ Fq,
    tagk <-$ Fq,
    gamma <-$ Fq,
    let r = r2 + r1,
    let D1' = g^(a1*alpha) * V^r,
    let D2' = g^-alpha * V1^r * g^z1,
    let D3 = (g^b)^-z1,
    let D4' = V2^r * g^z2,
    let D5 = (g^b)^-z2,
    let D6 = g^(b*r2),
    let D7 = g^r1,
    let k = (H * U^i * W^tagk)^r1,
    let D1 = D1' * g^(-a1*a2*gamma),
    let D2 = D2' * g^(a2*gamma),
    let D4 = D4' * g^(a1*gamma) ].

  (* -------------------------------------------------- *)
  (* sample exponents instead of group elements to maximize deducibility for reduction *)
  _: rnd V  (v :  Fq -> g ^ v) _.  _: rnd V1 (v1 : Fq -> g ^ v1) _.
  _: rnd V2 (v2 : Fq -> g ^ v2) _. _: rnd W  (w :  Fq -> g^w) _.
  _: rnd U  (u :  Fq -> g ^ u) _.  _: rnd H  (h :  Fq -> g^h) _.
  _: //; //=.


  (* -------------------------------------------------- *)
  (* introduce pairwise independent function A*i + B for tagc and tagk in =-oracle. *)
  _: rename tagc B.
  _: rnd_oracle (18,1,6,=) (tagk -> tagk*(KeyGen2`i - ci) + B) _. _: //; //=.
  _: swap_main (18,1,6) A. _: swap A (1). _: swap B (2).
  _: rnd! B (B -> B + A*ci) _. _: //; //=.

  (* b1,b2 and c1,c2 will be used in reduction *)
  _: rename b b1.
  (* v = -b2*a1*a2 *)
  _: rename v b2. _: except a1 [0]. _: except a2 [0]. _: rnd! b2 (b2 -> -b2*a1*a2) _; // ; //=.
  _: rnd! v1 (v1 -> v1 + b2*a2) _; //; //=.
  _: rnd! v2 (v2 -> v2 + b2*a1) _; //; //=.
  _: rnd! w (w -> w + b1) _; //; //=.
  _: rnd! u (u -> u - b1*A) _; //; //=.
  _: rnd! h (h -> h - b1*B) _; //; //=.
  
  (* introduce remaining variables c1 and c2 from assumption. *)
  _: abstract 1 arg (). _: abstract _ res _.  _: assumption_decisional dkill <- [arg] c2. _: //; //=.
  _: abstract 1 arg (). _: abstract _ res _.  _: assumption_decisional dkill <- [arg] c1. _: //; //=.
  _: swap b1 (1). _: swap b2 (2).

  _: rnd_oracle (21,1,2,=) (r1 -> r1 + c1) _. _: //; //=.
  _: rnd_oracle (21,1,3,=) (r2 -> r2 + c2) _. _: //; //=.
  _: rnd_oracle (21,1,4,=) (z1 -> z1 - v1*c2) _. _: //; //=.
  _: rnd_oracle (21,1,5,=) (z2 -> z2 - v2*c2) _. _: //; //=.
  
  _: rnd! t (t -> t + a1*a2*x*b2) _. _: //; //=.

  abstract* 5 arg (g^b1, g^b2, g^c1, g^(b1*c2), g^(b2*(c1+c2))).
  abstract _ res _.
  assumption_decisional dlin -> [arg] tt. _: //; //=.
  swap tt (21).
  swap_main tt (22,1,1) gamma.
  swap (21,1,1,=) 5.
  rnd_oracle (21,1,6,=) (gamma -> gamma + b2*c1 + b2*c2) _. //; //=.
  dist_eq.

(* make ciphertext one-time-pad by applying DBDH *)
rename a2 c2.
rename alpha c1.
except c2 [0]. rnd c1 (c1 -> c1 * c2) (c1 -> c1 / c2). except c2 []. unfold r3.
rnd V (v : Fq -> g^v) _. rnd V1 (v1 : Fq -> g^v1) _.
rnd V2 (v2 : Fq -> g^v2) _. rnd W (w : Fq -> g^w) _.
rnd H (h : Fq -> g^h) _. rnd U (u : Fq -> g^u) _. norm.
rnd_oracle (11,1,6) (gamma -> gamma + c1) _. norm.
rnd_oracle (18,1,7) (gamma -> gamma + c1) _. norm.
rename s2 c3. rename x x'. rnd x' (x' -> x' - c3) _. norm.
swap c1 (1). swap c2 (2). swap c3 (3).
abstract* 4 args (g^c1, g^c2, g^c3, e(g,g)^(c1*c2*c3)). abstract _ res _.
assumption_decisional dbdh -> [args] tt. norm.
except a1 [0]. except b [0]. rnd! tt _ _. norm. swap 13 beta'. indep!.
qed.