(* extracted from use of pairwise independent hash function in Waters scheme *)

adversary A1 : () -> Fq.
adversary A2 : Fq -> Bool.

oracle O : Fq -> Fq.

(* For the first adversary call *)
bound_dist
  [ j <- A1() with
        O(i) =
          [ (* for < *)
            [ t1 | t1 <-$ Fq ]
            (* for = *)
            [ t1 | t1 <-$ Fq ]
            (* for > *)
            [ t1 | t1 <-$ Fq ] ];
    t2 <-$ Fq;
    beta <- A2(t2);
  ] : beta
  [ a <-$ Fq;
    b <-$ Fq;
    j <- A1() with
        O(i) =
          [ (* for < *)
            [ t1 | t1 <-$ Fq ]
            (* for = *)
            [ a*i + b | t1 <-$ Fq ]
            (* for > *)
            [ t1 | t1 <-$ Fq ] ];
    beta <- A2(a*j + b);
  ] : beta.
  admit.
qed.

(* for the second adversary call *)
bound_dist
  [ j <- A1();
    t1 <-$ Fq;
    beta <- A2(t1)
      with
        O(i) =
          [ (* for < *)
            [ t | t <-$ Fq ]
            (* for = *)
            [ t
            | i <> j,
              t <-$ Fq
            ]
            (* for > *)
            [ t | t <-$ Fq ] ];
  ] : beta
  [ a <-$ Fq;
    b <-$ Fq;
    j <- A1();
    beta <- A2(a*j + b)
      with
        O(i) =
          [ (* for < *)
            [ t | t <-$ Fq ]
            (* for = *)
            [ a*i + b
            | i<>j
            ]
            (* for > *)
            [ t | t <-$ Fq ] ];
  ] : beta.
  
  swap t1 -1.
  rename t1 b.
  (* since we want to make A2's input depend on a and b, we have to adapt
     the oracle first (already taking the rnd rule later used for b into
     account *)
  rnd_oracle (3,1,2,=) (t -> t*(i - j) + b) _; //.
  swap_main (3,1,2) a.
  swap b a.
  rnd b (b -> b + a*j) _; //.
  swap b j.
  swap a b.
  dist_eq.
  qed.